# 1 交换机简介

- 简单模式
  - ![image-20220107131835048](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220107131835048.png)
- 发布订阅
  - ![交换机](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/333d0208c47a4e009fa722709afe659f.png)

> 介绍

1. RabbitMQ消息传递模型的核心思想是：`生产者生产的消息从不会直接发送到队列`。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中

2. 相反，生产者只能将消息发送到交换机(`exchange`)，交换机工作的内容非常简单

   - 一方面它接收来自生产者的消息，另一方面将它们推入队列。
   - 交换机必须确切知道如何处理收到的消息。
   - 是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。

3. 总共有以下几个类型：

   - 直接（`direct`）、主题（`topic`）、标题（`headers`）、扇出（`fanout`）

4. 无名交换机：

   - 在本教程的前面部分我们对 `exchange` 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(C")进行标识。

   - 第一个参数是交换机的名称。空字符串表示默认或无名称交换机:消息能路由发送到队列中其实是由 `routingKey(bindingkey)` 绑定 key 指定的，如果它存在的话

   - ```java
     channel.basiPublish("","hello",null,message.getBytes())；
     ```

# 2. 临时队列

1. 每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。

2. 创建临时队列的方式如下

   - ```java
     String queueName = channel.queueDeclare().getQueue();
     ```

   - 创建出来的队列长这样：

     - ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7CVgPn91-1630999921190)(D:\学习资料\图片\image-20210831171006251.png)]](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/508a61de15644f118f071ed989c1d6b0.png)

# 3. Bindings

> 简介

- 什么是`bingding`.呢, `binding` 其实是 `exchange` 和 `queue` 之间的桥梁，它告诉我们 `exchange` 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是×与Q1和Q2进行了绑定
- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/46f9af7462f3468da5e43990faa7c328.png)
- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/c12d0c944d2a4d2fa3fb90dc1ba1f74c.png)
- 保证交换机可以**准确的将消息发送给某一个队列**



# 4. Fanout 发布

- 它是将**接收到的所有消息`广播`到它知道的所有队列中**。系统中默认有些`exchange`类型
- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/3cdbfd3af4bd420c9ee550ec2f5823dd.png)



## 4.1 Fanout 实战

- ![image-20220107133653032](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220107133653032.png)
- Logs (交换机) 和临时队列的绑定关系如下图
- ![image-20220107133709180](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220107133709180.png)

- `RoutingKey` 都一样

### 消费者 01

- ```java
  /*
   * 消息接收
   * */
  public class ReceiveLogs01 {
  
      // 交换机名称
      public static final String EXCHANGE_NAME = "logs";
  
      public static void main(String[] args) throws Exception{
          Channel channel = RabbitMqUtils.getChannel();
  
          // 声明一个交换机
          channel.exchangeDeclare(EXCHANGE_NAME, "fanout");
  
          //  声明一个队列,名称随机，当消费者断开与队列的连接时，队列自动删除
          String queueName = channel.queueDeclare().getQueue();
  
          //绑定交换机与队列,最后一个参数是 routing key
          channel.queueBind(queueName, EXCHANGE_NAME, "");
          System.out.println("等待接受消息，把接受到的消息打印在屏幕上...");
  
  
          DeliverCallback deliverCallback = (consumerTag,message) -> {
              System.out.println("ReceiveLogs01控制台打印接受到的消息：" + new String(message.getBody()));
          };
  
          channel.basicConsume(queueName,true,deliverCallback,consumerTag -> {});
      }
  }
  ```

### 消费者02

- ```java
   /*
    * 消息接收
    * */
   public class ReceiveLogs02 {
   
       //交换机名称
       public static final String EXCHANGE_NAME = "logs";
   
       public static void main(String[] args) throws Exception{
           Channel channel = RabbitMqUtils.getChannel();
    
           //声明一个队列,名称随机，当消费者断开与队列的连接时，队列自动删除
           String queueName = channel.queueDeclare().getQueue();
    
           //绑定交换机与队列,最后一个参数是 routing key
           channel.queueBind(queueName, EXCHANGE_NAME, "");
           System.out.println("等待接受消息，把接受到的消息打印在屏幕上...");
   
   
           DeliverCallback deliverCallback = (consumerTag,message) -> {
               System.out.println("ReceiveLogs02控制台打印接受到的消息：" + new String(message.getBody()));
           };
   
           channel.basicConsume(queueName,true,deliverCallback,consumerTag -> {});
       }
   }

### 生产者

- ```java
  /*
   *  发消息 交换机
   */
  public class Emitlog {
      // 交换机的名称
      public  static  final String EXCHANGE_NAME = "logs";
  
      public static void main(String[] args) throws  Exception{
          // 连接信道  
          Channel channel = RabbitMqUtils.getChannel();
          // 声明交换机
          channel.exchangeDeclare(EXCHANGE_NAME,"fauout");
  
          // 手动输入消息
          Scanner scanner = new Scanner(System.in);
          while (scanner.hasNext()){
              String message = scanner.next();
              // 发送消息，rounting key 为 ""
              channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes(StandardCharsets.UTF_8));
              System.out.println("生产者发出的消息："+ message);
          }
      }
  }
  ```

### 结果

- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/b36a316e9ed44c1884da024e4797ccd1.png)
- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/a3d5f0e8ede14445912ae4245f7d9354.png)
- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/09cc33d93e4a423496fc85619a807d65.png)



# 5. Direct Exchange 直接交换机（路由模式）

- ![image-20220107143543278](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220107143543278.png)
- ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nx204PBS-1630999921190)(D:\学习资料\图片\image-20210901145539483.png)]](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/8a546dbb8c0a4456a89d7c753114475c.png)
- ![image-20220107143619332](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220107143619332.png)



## 5.2 多重绑定

![image-20220107143647769](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220107143647769.png)



- 当然如果`exchange`的绑定类型是`direct`，但是它绑定的多个队列的`key`。
- 如果都相同，在这种情况下虽然绑定类型是`direct`但是它表现的就**和`fanout`有点类似了，就跟广播差不多**，如上图所示。



## 5.3 实战

### 消费者01

- ```java
  public class ReceiveLogsDirect01 {
      public static final String EXCHANGE_NAME = "direct_logs";
  
      public static void main(String[] args) throws Exception {
          Channel channel = RabbitMqUtils.getChannel();
  
          // 声明一个队列
          channel.queueDeclare("console",false,false,false,null);
  
          // 绑定交换机与队列, 绑定 routing key：info, warning
          channel.queueBind("console",EXCHANGE_NAME,"info");
          channel.queueBind("console",EXCHANGE_NAME,"warning");
  
  
          DeliverCallback deliverCallback = (consumerTag, message) -> {
              System.out.println("ReceiveLogsDirect01控制台打印接受到的消息：" + new String(message.getBody()));
          };
  
          channel.basicConsume("console",true,deliverCallback,consumerTag -> {});
      }
  }
  ```

### 消费者02

- ```java
  public class ReceiveLogsDirect02 {
      public static final String EXCHANGE_NAME = "direct_logs";
  
      public static void main(String[] args) throws Exception {
          Channel channel = RabbitMqUtils.getChannel();
  
          //声明一个队列
          channel.queueDeclare("disk",false,false,false,null);
  
          //绑定交换机与队列
          channel.queueBind("disk", EXCHANGE_NAME, "error");
  
  
          DeliverCallback deliverCallback = (consumerTag, message) -> {
              System.out.println("ReceiveLogsDirect02控制台打印接受到的消息：" + new String(message.getBody()));
          };
  
          channel.basicConsume("disk",true,deliverCallback,consumerTag -> {});
      }
  }
  
  ```

### 生产者

- 指定 `routing key`，确定要给那个 `queue` 发送消息

- ```java
  public class DirectLogs {
      // 交换机的名称
      public  static  final String EXCHANGE_NAME = "direct_logs";
  
      public static void main(String[] args) throws  Exception{
          Channel channel = RabbitMqUtils.getChannel();
          channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
  
          Scanner scanner = new Scanner(System.in);
          while (scanner.hasNext()){
              String message = scanner.next();
              // 发送消息，指定 routing key 为 "info"
              channel.basicPublish(EXCHANGE_NAME, "info", null,message.getBytes(StandardCharsets.UTF_8));
              System.out.println("生产者发出的消息："+ message);
          }
      }
  }
  ```

# 6. Topics 主题交换机（最强大）

## 1. 之前类型的问题

- 在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的`fanout`交换机，而是使用了`direct`交换机，从而有能实现有选择性地接收日志
- 尽管使用`direct`交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有`info.base`和`info.advantage`，某个队列只想`info.base`的消息，那这个时候`direct`就办不到了。这个时候就只能使用`topic`类型

## 2. Topic的要求

- 发送到类型是`topic`交换机的消息的`routing_key`不能随意写，必须满足一定的要求
  - 它**必须是一个单词列表，以点号分隔开**。
  - 这些单词可以是任意单词，比如说：`"stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit"`这种类型的。当然这个单词列表最多不能超过255个字节。
- 在这个规则列表中，其中有两个替换符是大家需要注意的
  - `*`**(星号)可以代替一个单词**
  - **`#`(井号)可以替代零个或多个单词**
  - 当一个队列绑定键是`#`,那么这个队列将**接收所有数据**，就有点像 `fanout` 了
  - 如果队列绑定键当中**没有`#`和`*`出现**，那么该队列绑定类型就是`direct`了

### 2.1 匹配案例

- Q1绑定的是：中间带orange的三个单词的字符串：`*.orange.*`
- Q2绑定的是：最后一个单词是rabbit的单个单词：`*.*.rabbit`，第一个单词是lazy的多个单词：`lazy.#`
- ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZmvmyJnt-1630999921191)(D:\学习资料\图片\image-20210901150251926.png)]](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/9a7819422df6426fbd12fb6321bdd571.png)

数据接收情况如下：

- `quick.orange.rabbit`：被队列Q1Q2接收到
- `quick.orange.fox`：被队列Q1接收到
- `lazy.brown.fox`：被队列Q2接收到
- `lazy.pink.rabbit`：虽然满足队列Q2的两个绑定但是只会被接收一次
- `quick.brown.fox`：不匹配任何绑定不会被任何队列接收到会被丢弃
- `quick.orange.male.rabbit`：四个单词不匹配任何绑定会被丢弃
- `lazy.orange.male.rabbit`：是四个单词但匹配Q2

## 3. Topic实战

### 生产者

- ```java
  public class EmitLogTopic {
      //交换机的名称
      public static final String EXCHANGE_NAME = "topic_logs";
  
      public static void main(String[] args)  throws Exception{
          Channel channel = RabbitMqUtils.getChannel();
  
          HashMap<String, String> map = new HashMap<>();
          map.put("quick.orange.rabbit","被队列Q1Q2接收到");
          map.put("quick.orange.fox","被队列Q1接收到");
          map.put("lazy.brown.fox","被队列Q2接收到 ");
          map.put("lazy.pink.rabbit","虽然满足队列Q2的两个绑定但是只会被接收一次");
          map.put("quick.orange.male.rabbit","四个单词不匹配任何绑定会被丢弃");
  
          for (Map.Entry<String, String> bindingKeyEntry : map.entrySet()) {
              String routingKey = bindingKeyEntry.getKey();
              String message = bindingKeyEntry.getValue();
  
              channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(StandardCharsets.UTF_8));
              System.out.println("生产者发送消息：" + message);
          }
      }
  }
  ```

### 消费者01

- ```java
  /*
  * 声明主题交换机及相关队列
  * 消费者C1
  * */
  public class ReceiveLogsTopic01 {
      //交换机名称
      public static final String EXCHANGE_NAME = "topic_logs";
  
      public static void main(String[] args)  throws Exception{
          Channel channel = RabbitMqUtils.getChannel();
  
          //声明交换机
          channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
  
          //声明队列
          String queueName = "Q1";
          channel.queueDeclare(queueName, false, false, false, null);
  
          //队列捆绑
          channel.queueBind(queueName, EXCHANGE_NAME, "*.orange.*");
          System.out.println("等待接收消息......");
  
          DeliverCallback deliverCallback = (consumerTag, message) -> {
              System.out.println(new String(message.getBody()));
              System.out.println("接收队列："+ queueName + "绑定键：" + message.getEnvelope().getRoutingKey());
          };
  
          //接收消息
          channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});
      }
  }
  ```

### 消费者02

- ```java
  /*
  * 声明主题交换机及相关队列
  * 消费者C2
  * */
  public class ReceiveLogsTopic02 {
      //交换机名称
      public static final String EXCHANGE_NAME = "topic_logs";
  
      public static void main(String[] args)  throws Exception{
          Channel channel = RabbitMqUtils.getChannel();
  
          //声明交换机
          channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
  
          //声明队列
          String queueName = "Q2";
          channel.queueDeclare(queueName,false,false,false,null);
  
          //队列捆绑
          channel.queueBind(queueName,EXCHANGE_NAME, "*.*.rabbit");
          channel.queueBind(queueName,EXCHANGE_NAME, "*lazy.#");
          System.out.println("等待接收消息......");
  
          DeliverCallback deliverCallback = (consumerTag,message) -> {
              System.out.println(new String(message.getBody()));
              System.out.println("接收队列："+ queueName + "绑定键：" + message.getEnvelope().getRoutingKey());
          };
  
          //接收消息
          channel.basicConsume(queueName,true,deliverCallback,consumerTag -> {});
      }
  }
  ```

- 





























































































