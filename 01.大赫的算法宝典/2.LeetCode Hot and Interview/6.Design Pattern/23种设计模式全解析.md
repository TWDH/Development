# 23种设计模式全解析

![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/57a92d42-4d84-3aa9-a8b9-63a0b02c2c36.jpg)

## 一、设计模式的分类

- 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式



## 二、设计模式的六大原则 - S.O.L.I.D

### 1.1 Single Responsibility Principle 单一责任原则

- **一个类应该有且只有一个去改变他的理由，这意味着一个类应该只有一项工作**

- 类被赋予了 2 项工作，原来只是计算面积，现在还需要用 json 打印出来

  - 没准还想打印出 text、xml ，与 Area Calculator 不符

  - ```java
    public class AreaCalculator{
        private float result;
        
        public float getResult(){
            return this.result;
        }
        
        public float calculateArea(Triangle t){
            this.result = h * b / 2;
        }
        
        // 新增方法：不好
        public void printResultInJson(){
            jsonPrinter.initialize();
            jsonPrinter.print(this.result);
            jsonPrinter.close();
        }
    }
    ```

- 正确做法

  - 变成 2 个类，然后各司其职

  - ```java
    public class AreaCalculator{
        private float result;
        
        public float getResult(){
            return this.result;
        }
        
        public float calculateArea(Triangle t){
            this.result = h * b / 2;
        }
    }
    
    public class Printer{
        public void printResultInJson(){
            jsonPrinter.initialize();
            jsonPrinter.print(this.result);
            jsonPrinter.close();
        }
    }
    ```

### 1.2 Open Close Principle 开放封闭原则

- 对象或实体应该对 **扩展开放**、对**修改封闭** (Open to extension, close to modification)

- ```java
  // 反例
  public class AreaCalculator{
      public float calculateArea(Triangle t){
          // calculate the area for triangle
      }
      
      public float calculateArea(Rectangle r){
          // calculates the area for rectangle
      }
  }
  ```

  - 加入 Rectangle 违反开放封闭原则，如果有其他图像，需要**添加各种各样的函数**

- ```java
  // 抽象接口
  public interface Shape{
      public float getArea();
  }
  
  public class Triangle implements Shape{
      public float getArea(){
          return b * h / 2;
      }
  }
  
  // ================================================================
  
  public class AreaCalculator{
      private float result;
      
      public float getResult(){
          return this.result;
      }
      
      // 传入 Shape，而不是特定的某个图形
      public float calculateArea(Shape s){
          this.result = s.getArea();
      }
  }
  ```

### 1.3 Liskov Substitution Principle 里氏替换原则

- **任何一个 子类 或 派生类 应该可以替换他们的基类或父类**

  - 父类：人类 （吃喝拉撒）
  - 子类：机器人（不能吃喝拉撒）

- ```java
  public class Shape{
      // 计算体积（立体）
      abstract public float calculateVolumn();
      // 计算面积（平面）
      abstract public float calculateArea();
  }
  
  // 正例： Cube 可以计算体积和面积
  public class Cube extends Shape{}
  
  // 反例： Rectangle 不可以计算体积
  public class Rectangle extends Shape{}
  ```

  - 解决方案：建立 **立体图形类** 和 **平面图形类**
    - 不用怕父类定义的多

### 1.4 Interface Segregation Principle 接口分离原则

- **不应该强迫一个类实现它用不上的接口**
  - 父类：人类 （吃喝拉撒）
  - 子类：机器人（**强迫**吃喝拉撒）

### 1.5 Dependency Inversion Principle 依赖反转原则

- **抽象不应该依赖于具体实现，具体实现应该依赖于抽象**

- **High-level的实体不应该依赖于low-level的实体**

- ```java
  public class AreaCalculator{
      private float result;
      private Triangle t;
      
      public float getResult(){
          return this.result;
      }
      
      public float calculateArea(Triangle t){
          this.result = h * b / 2;
      }
  }
  ```

  - `AreaCalculate` 对 `Triangle`（外部类） **有依赖**

    - 如果 Triangle 被删除了，则无法编译
    - 如果 Triangle 中的 `h` or `b` 变成 **private**，则无法调用，直接影响 AreaCalculator

  - 应该依赖于 **抽象的**，如 Shape                                             

    - ```java
      public class AreaCalculator{
          private float result;
          
          public float getResult(){
              return this.result;
          }
          
          // 传入 Shape，而不是特定的某个图形
          public float calculateArea(Shape s){
              this.result = s.getArea();
          }
      }
      ```

### 1.6 迪米特法则（最少知道原则）（Demeter Principle）

- 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
- 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

### 1.7 合成复用原则（Composite Reuse Principle）

原则是尽量首先使用合成/聚合的方式，而不是使用继承。



## 三、Java的23中设计模式

## A、创建模式

### 0. 简单工厂模式

- 首先，简单工厂模式不属于23中涉及模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂
- 简单工厂模式模式分为三种：

#### 01. 普通

- 就是建立一个**工厂类**，对实现了同一接口的一些类进行 **实例的创建**

- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/421a1a3f-6777-3bca-85d7-00fc60c1ae8b.png)

- 举例如下：（我们举一个发送邮件和短信的例子）

- 首先，创建二者的共同接口：

  - ```java
    public interface Sender {  
        public void Send();  
    }  
    ```

- 创建实现类：

  - ```java
    public class MailSender implements Sender {  
        @Override  
        public void Send() {  
            System.out.println("this is mailsender!");  
        }  
    }  
    ```

  - ```java
    public class SmsSender implements Sender {  
        @Override  
        public void Send() {  
            System.out.println("this is sms sender!");  
        }  
    }  
    ```

- 建工厂类：

  - ```java
    public class SendFactory {
        public Sender produce(String type) {  
            if ("mail".equals(type)) {  
                return new MailSender();  
            } 
            else if ("sms".equals(type)) {  
                return new SmsSender();  
            } 
            else {  
                System.out.println("请输入正确的类型!");  
                return null;  
            }
        }
    }
    ```

- 主类：

  - ```java
    public class FactoryTest {  
        public static void main(String[] args) {  
            SendFactory factory = new SendFactory();  
            Sender sender = factory.produce("sms");  
            sender.Send();  
        }  
    } 
    // 输出：this is sms sender!
    ```

#### 02. 多个方法

- 是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象

- 而多个工厂方法模式是**提供多个工厂方法，分别创建对象**。关系图：

- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/84673ccf-ef89-3774-b5cf-6d2523cd03e5.jpg)

- SendFactory

  - ```java
    // 创建实现类
    public class MailSender implements Sender {  
        @Override  
        public void Send() {  
            System.out.println("this is mailsender!");  
        }  
    }  
    
    public class SmsSender implements Sender {  
        @Override  
        public void Send() {  
            System.out.println("this is sms sender!");  
        }  
    }  
    
    // 创建工厂类
    public class SendFactory {  
        public  Sender produceMail(){  
            return new MailSender();  
        }  
    
        public Sender produceSms(){  
            return new SmsSender();  
        }  
    }
    
    // 主类
    public class FactoryTest {  
        public static void main(String[] args) {  
            SendFactory factory = new SendFactory();  
            Sender sender = factory.produceMail();  
            sender.Send();  
        }  
    }  
    
    输出：this is mailsender!
    ```

#### 03. 多个静态方法

- 将上面的多个工厂方法模式里的**方法置为静态**的，不需要创建实例，直接调用即可。

- ```java
  // 工厂类
  public class SendFactory {  
      public static Sender produceMail(){  
          return new MailSender();  
      }  
        
      public static Sender produceSms(){  
          return new SmsSender();  
      }  
  }  
  
  // 主类
  public class FactoryTest {  
      public static void main(String[] args) {      
          Sender sender = SendFactory.produceMail();  
          sender.Send();  
      }  
  }  
  ```

#### 04. 总结

- 总体来说，工厂模式适合：凡是出现了**大量的产品需要创建**，并且具有共同的接口时，可以通过工厂方法模式进行创建。
- 在以上的三种模式中
  - 第一种如果传入的字符串有误，不能正确创建对象
  - 第三种相对于第二种，不需要实例化工厂类
  - 所以，大多数情况下，我们会选用第三种——静态工厂方法模式。

### 1. 工厂方法模式（Factory Method）

- 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，**必须对工厂类进行修改**，这违背了闭包原则，所以，从设计角度考虑，有一定的问题
- 如何解决？就用到工厂方法模式，**创建一个工厂接口** 和 **创建多个工厂实现类**
- 这样一旦需要**增加新的功能**，直接 **增加新的工厂类** 就可以了，不需要修改之前的代码。
- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/34a0f8de-16e0-3cd5-9f69-257fcb2be742.jpg)

#### 01. 工厂方法模式

- Factory ---> Sender ---> send() 

- ```java
  // interface
  public interface Sender {  
      public void Send();  
  }  
  
  // 两个实现类
  public class MailSender implements Sender {  
      @Override  
      public void Send() {  
          System.out.println("this is mailsender!");  
      }  
  }  
  
  public class SmsSender implements Sender {  
      @Override  
      public void Send() {  
          System.out.println("this is sms sender!");  
      }  
  }  
  
  // 再提供一个接口
  public interface Provider {  
      public Sender produce();  
  } 
  
  // 两个工厂类
  public class SendMailFactory implements Provider {  
      @Override  
      public Sender produce(){  
          return new MailSender();  
      }  
  } 
  
  public class SendSmsFactory implements Provider{  
      @Override  
      public Sender produce() {  
          return new SmsSender();  
      }  
  }  
  
  // 主类
  public class Test {  
      public static void main(String[] args) {  
          Provider provider = new SendMailFactory();  
          Sender sender = provider.produce();  
          sender.Send();  
      }  
  }  
  ```

- 这个模式的好处就是，如果你现在想**增加一个功能**：发及时信息，则**只需做一个实现类**，**实现 Sender 接口**

- 同时做一个工厂类，**实现Provider接口**，就OK了，无需去改动现成的代码。这样做，拓展性较好！

### 2. 抽象工厂模式

- 工厂方法模式 和 抽象工厂模式区别
  - 工厂方法模式：
    - 一个 **抽象产品类**，可以派生出 **多个具体产品类**
    - 一个 **抽象工厂类**，可以派生出 **多个具体工厂类**
    - 每个具体工厂类只能创建一个具体产品类的实例
  - 抽象工厂模式：
    - **多个 抽象产品类**，每个抽象产品类可以派生出 **多个具体产品类**
    - 一个抽象工厂类，可以派生出 **多个具体工厂类**
    - 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品
  - 区别
    - **工厂方法模式** 只有 **一个抽象产品类**，而 **抽象工厂模式** 有 **多个**
    - **工厂方法模式** 的具体工厂类只能 **创建一个具体产品类** 的实例，而 **抽象工厂模式** 可以创建 **多个**
- Definition
  - ***defining an interface to create families of related or dependent objects without specifying their concrete classes.***
- Class Diagram
  - Abstract Factory
  - Concrete Factory
  - Abstract Product
  - Concrete Product
  - Client
  - ![image-20220405105247507](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220405105247507.png)

#### 2.1 Code to an interface not to an implementation

- hide the concrete classes and expose interfaces to clients

- ```java
  // Engin interface
  public interface IEngine {
      // method: start
      void start();
  }
  
  // concrete class
  public class F16Engine implements IEngine {
      @Override
      public void start() {
          System.out.println("F16 engine on");
      }
  }
  
  // client
  public void main() {
      IEngine f16Engine = new F16Engine();
      List<IEngine> engines = new ArrayList<>();
      engines.add(f16Engine);
      for (IEngine engine : engines) {
          engine.start();
      }
  }
  ```

- consumer code is free of the implementation details of what class implements the F-16 engine

- hide the new `F16Engine()` part of the code

- We don't want the consumer to know what class we are instantiating

#### 2.2 Creating a factory

- a class responsible for **manufacturing the requested objects** and returning them to the client

- ```java
  // Engin interface
  public interface IEngine {
      // method: start
      void start();
  }
  
  // concrete class
  public class F16Engine implements IEngine {
      @Override
      public void start() {
          System.out.println("F16 engine on");
      }
  }
  
  // Factory
  public class F16Factory {
      public IEngine createEngine() {
          return new F16Engine();
      }
  
      public IWings createWings() {
          return new F16Wings();
      }
  
      public ICockpit createCockpit() {
          return new F16Cockpit();
      }
  }
  
  // client
  public void main(F16Factory f16Factory) {
      
      IEngine f16Engine = f16Factory.createEngine();
      
      List<IEngine> engines = new ArrayList<>();
      engines.add(f16Engine);
      
      for (IEngine engine : engines) {
          engine.start();
      }
  }
  ```

  1. create the various parts of the F16 aircraft
  2. deliver them to the requesting client

- **allows us the freedom to change the concrete class** representing the `F16Engine` as long as it commits to the IEngine interface

- just **differing the factory class passed into the client constructor**, we are able to provide the client with the same parts for a **completely new aircraft**.

#### 2.3 Factory of Factories

- ```java
  // Abstract Factory Interface
  // its create methods are not returning concrete parts, but rather interfaces
  public interface IAircraftFactory {
      IEngine createEngine();
      IWings createWings();
      ICockpit createCockpit();
  }
  
  // Factory
  // Each part has a corresponding product interface
  public class F16Factory implements IAircraftFactory {
      @Override
      public IEngine createEngine() {
          return new F16Engine();
      }
      @Override
      public IWings createWings() {
          return new F16Wings();
      }
      @Override
      public ICockpit createCockpit() {
          return new F16Cockpit();
      }
  }
  
  public class Boeing747Factory implements IAircraftFactory {
      @Override
      public IEngine createEngine() {
          return new Boeing747Engine();
      }
      @Override
      public IWings createWings() {
          return new Boeing747Wings();
      }
      @Override
      public ICockpit createCockpit() {
          return new Boeing747Cockpit();
      }
  }
  
  // Product(Engin) interface
  public interface IEngine {
      // method: start
      void start();
  }
  
  // concrete class
  public class F16Engine implements IEngine {
      @Override
      public void start() {
          System.out.println("F16 engine on");
      }
  }
  
  // client
  public class Client {
      public void main() {
          // Instantiate a concrete factory for F-16
          F16Factory f16Factory = new F16Factory();
          
          // Instantiate a concrete factory for Boeing-747
          Boeing747Factory boeing747Factory = new Boeing747Factory();
         
          // Lets create a list of all our airplanes
          Collection<Aircraft> myPlanes = new ArrayList<>();
          
          // Create a new F-16 by passing in the f16 factory
          myPlanes.add(new Aircraft(f16Factory));
          
          // Create a new Boeing-747 by passing in the boeing factory
          myPlanes.add(new Aircraft(boeing747Factory));
          
          // Fly all your planes
          for (Aircraft aircraft : myPlanes) {
              aircraft.fly();
          }
      }
  }
  
  // Entity: make the product
  public class Aircraft {
      IEngine engine;
      ICockpit cockpit;
      IWings wings;
      IAircraftFactory factory;
      
      public Aircraft(IAircraftFactory factory) {
          this.factory = factory;
      }
      
      // 1. get manufactured
      protected Aircraft makeAircraft() {
          engine = factory.createEngine();
          cockpit = factory.createCockpit();
          wings = factory.createWings();
          return this;
      }
      
      // 2. taxi on the runway
      private void taxi() {
          System.out.println("Taxing on runway");
      }
      
      // 3. fly away
      public void fly() {
          Aircraft aircraft = makeAircraft();
          aircraft.taxi();
          System.out.println("Flying");
      }
  }
  ```

  - All the **create** methods are actually **factory methods**
  - factory method pattern is utilized when implementing the abstract factory pattern.
  - **Just by composing the aircraft object with a different factory we are able to get a different aircraft.**



## C

### Strategy Pattern

- **Grouping related algorithms under an abstraction**,  which the client codes against.
- The abstraction allows **switching out one algorithm or policy** for another **without modifying the client**.
- Formally Defined
  - **Encapsulating algorithms belonging to the same family** and making them **interchangeable**. 
  - The consumers of the common interface that the algorithms implement allow **switching out one algorithm for another seamlessly**.

#### Class Diagram

- Strategy
- Concrete Strategy
- Context
- ![image-20220405120825788](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220405120825788.png)

#### Examples

- **Concrete algorithms implement the same interface.**

- The **context has the data** the algorithm will act on.

- Clients **instantiate the context** and **pass in the strategy object**, then only interact with the context object

- ```java
  // Strategy Interface
  public interface ISort {
      void sort(int[] input);
  }
  
  // Concrete Implementation
  public class BubbleSort implements ISort {
      @Override
      public void sort(int[] input) {
          // Do inefficient sorting in order n squared
      }
  }
  
  public class MergeSort implements ISort {
      @Override
      public void sort(int[] input) {
          // Do efficient sorting in nlogn
      }
  }
  
  // Context
  public class Context {
      private ISort howDoISort;
      
      public Context(ISort howDoISort) {
          this.howDoISort = howDoISort;
      }
      
      // Context receives the data from its client
      // and passes it on to the strategy object.
      void sort(int[] numbers) {
          howDoISort.sort(numbers);
      }
      
      // We can change the sorting algorithm using this setter
      public void setHowDoISort(ISort howDoISort) {
          this.howDoISort = howDoISort;
      }
  }
  
  // Clients
  public class Client {
      private int[] numbers = new int[1000];
      void crunchingNumbers() {
          // Choose the sorting strategy
          BubbleSort bubbleSort = new BubbleSort();
          
          // Context receives the strategy object
          Context context = new Context(bubbleSort);
          
          // Sort the numbers
          context.sort(numbers);
          // Do remaining work
      }
  }
  ```

- The context keeps an **interface reference** and can be **configured with any concrete sort implementation**.

- The implementation can also **be changed at runtime** through the setter.

- This decoupling of the client and the algorithms, allows us to vary the algorithms independent of the client.





























































