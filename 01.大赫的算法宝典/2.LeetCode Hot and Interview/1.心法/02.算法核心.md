# 算法核心

## 回文串

- *寻找* **回文串**的核心思想是从**中心向两端扩展**

  - ```java
    string palindrome(String s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.size() && s[l] == s[r]) {
            // 向两边展开
            l--; r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r );
    }
    ```

- 判断 回文串

  - 「双指针技巧」，从两端向中间逼近即可

  - ```java
    public boolean isPalindrome(string s) {
        int left = 0, right = s.length - 1;
        
        while (left < right) {
            if (s[left] != s[right]){
                return false;
            }
                
            left++; right--;
        }
        return true;
    }
    ```


- ![image-20220222234815630](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220222234815630.png)

  - ```java
    // 弹出 x 的末尾数字 digit
    digit = x % 10
    x /= 10
    
    // 将数字 digit 推入 rev 末尾
    rev = rev * 10 + digit
    ```

  - [7. Reverse Integer](https://leetcode-cn.com/problems/reverse-integer/)

  - [labuladong: 计算器](https://labuladong.github.io/algo/4/32/136/)

- 快速加/幂

  - ```java
    public long quickAdd(long quotient, long divisor){
        long ans = 0;
        while(divisor > 0){
            // odd numver
            if((divisor & 1) == 1){
                ans += quotient;
            }
    
            quotient += quotient;
            divisor >>= 1;
        }
        return ans;
    }
    ```

  - ```java
    public double quickMul(double x, long N) {
            double ans = 1.0;
            // 贡献的初始值为 x
            double x_contribute = x;
            // 在对 N 进行二进制拆分的同时计算答案
            while (N > 0) {
                if (N % 2 == 1) {
                    // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                    ans *= x_contribute;
                }
                // 将贡献不断地平方
                x_contribute *= x_contribute;
                // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
                N /= 2;
            }
            return ans;
        }
    ```


