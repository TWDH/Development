# JAVA EE

## **Access Modifiers** (访问修饰符)

1. private / protected / public / default

2. | **Modifier**                     | **Default** | **Private** | **Protected** | **Public** |
   | -------------------------------- | ----------- | ----------- | ------------- | ---------- |
   | *Same class*                     | YES         | YES         | YES           | YES        |
   | *Same Package subclass*          | YES         | NO          | YES           | YES        |
   | *Same Package non-subclass*      | YES         | NO          | YES           | YES        |
   | *Different package subclass*     | NO          | NO          | YES           | YES        |
   | *Different package non-subclass* | NO          | NO          | NO            | YES        |




## Final

1. final variable
   - 值不能被改变
2. final method
   - 不能被重写 （overridden）
3. final class
   - 不能被继承（extend）



## **OOP 要素**

1. **Inheritance (继承)**
2. **Encapsulation (封装)**
3. **Polymorphism (多态)**
   - one interface, many implementations
   - Compile Time (编译时多态)
     - overloading（重载 - 方法名相同，参数不同）
   - Run Time（运行时多态）
     - inheritance（继承 - 方法名相同，覆盖父类）
     - interface（接口）与  Abstraction（抽象）
4. **Abstraction (抽象)**
   - 隐藏实现细节，仅提供功能接口



## 抽象类和接口

1. 抽象（抽象类 和 接口）
   - hiding the implementation details
   - 抽象类：**对类本质的抽象**， `is a` 关系（BMW is a car）；包含且实现 子类通用特性，子类存在差异化的特性抽象，交给子类实现
   - 接口：**对行为的抽象**， `like a` 关系（Bird like a Aircraft 可以飞），本质上 `is a bird`；
     - 定义行为，实现类 *做* 什么；实现类主题是谁，如何实现，接口不关心
2. 抽象类和接口 - 区别
   - **接口** 是公开的，不能有私有的方法或变量，接口中的所有方法都 `没有方法体`，通过关键字 `interface` 实现。
   - **抽象类** 是可以有私有方法或私有变量的，通过把类或者类中的方法声明为`abstract`来表示一个类是抽象类，被声明为抽象的方法 `不能包含方法体`。
3. 抽象类和接口 - 相同点
   - 都不能被实例化
   - 接口的实现类或抽象类的子类都只有 *实现了接口或抽象类中的方法后才能实例化*。
4. 抽象类和接口 - 不同点
   - 接口只有定义，不能有方法的实现，java 1.8中可以定义 `default` 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
   - 实现接口的关键字为 `implements`，继承抽象类的关键字为 `extends`。**一个类可以实现多个接口**，但**一个类只能继承一个抽象类**。所以，使用接口可以间接地实现多重继承。
   - 接口强调 **特定功能** 的实现，而抽象类强调 **所属关系**。
   - **接口**成员变量默认为 `public static final`，必须赋初值，不能被修改；其所有的成员方法都是 `public`、`abstract` 的。抽象类中成员变量默认 `default`，可在子类中被重新定义，也可被重新赋值；
   - **抽象**方法被 `abstract` 修饰，不能被`private`、`static`、`synchronized` 和 `native` 等修饰，必须以分号结尾，不带花括号。
   - 接口被用于常用的功能，便于日后维护和添加删除，而**抽象类更倾向于充当公共类的角色**，不适用于日后重新对里面的代码修改。**功能需要累积** 时用抽象类，不需要累积时用接口。



## Exception

- Checked Exception
  - Checked exceptions are **checked at compile-time**.
    - **编译器**要检查这类异常
    - 必须处理（try ...catch）的异常
  - Example: `IOException`, `SQLException` etc.
- Unchecked Exception （Runtime Exception）
  - The classes that **extend `RuntimeException`** are known as unchecked exceptions. 
  - Unchecked exceptions are **not checked at compile-time**.
  - Example: `ArithmeticException`, `NullPointerException` etc.



## Processes (进程) and Threads (线程) 

|                   | **Process**                                                  | **Thread**                                                   |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Definition**    | An executing **instance of a program** is called a process.  | A thread is a **subset of the process**.                     |
| **Communication** | Processes must use inter-process communication to communicate with sibling processes. | Threads can directly communicate with other threads of its process. |
| **Control**       | Processes can only exercise control over child processes.    | Threads can exercise considerable control over threads of the same process. |
| **Changes**       | Any change in the parent process does not affect child processes. | Any change in the main thread may affect the behavior of the other threads of the process. |
| **Memory**        | Run in separate memory spaces.                               | Run in **shared memory spaces**.                             |
| **Controlled by** | Process is controlled by the operating system.               | Threads are controlled by programmer in a program.           |
| **Dependence**    | Processes are independent.                                   | Threads are dependent.                                       |



# Spring



## Spring依赖注入有哪几种方式

- [Spring依赖注入有哪几种方式](https://www.zhihu.com/question/452470872)
- Field
  - 接口注入 依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。
  - 优点 接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。
  - 缺点： 侵入行太强，不建议使用。
- ![image-20220429225558031](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220429225558031.png)
- ![image-20220429230709603](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220429230709603.png)





















