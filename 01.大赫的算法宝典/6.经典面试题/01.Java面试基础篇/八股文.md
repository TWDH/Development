# JAVA EE

## **Access Modifiers** (访问修饰符)

1. private / protected / public / default

2. | **Modifier**                     | **Default** | **Private** | **Protected** | **Public** |
   | -------------------------------- | ----------- | ----------- | ------------- | ---------- |
   | *Same class*                     | YES         | YES         | YES           | YES        |
   | *Same Package subclass*          | YES         | NO          | YES           | YES        |
   | *Same Package non-subclass*      | YES         | NO          | YES           | YES        |
   | *Different package subclass*     | NO          | NO          | YES           | YES        |
   | *Different package non-subclass* | NO          | NO          | NO            | YES        |




## Final

1. final variable
   - 值不能被改变
2. final method
   - 不能被重写 （overridden）
3. final class
   - 不能被继承（extend）



## **OOP 要素**

1. **Inheritance (继承)**
2. **Encapsulation (封装)**
3. **Polymorphism (多态)**
   - one interface, many implementations
   - Compile Time (编译时多态)
     - overloading（重载 - 方法名相同，参数不同）
   - Run Time（运行时多态）
     - inheritance（继承 - 方法名相同，覆盖父类）
     - interface（接口）与  Abstraction（抽象）
4. **Abstraction (抽象)**
   - 隐藏实现细节，仅提供功能接口



## 抽象类和接口

1. 抽象（抽象类 和 接口）
   - hiding the implementation details
   - 抽象类：**对类本质的抽象**， `is a` 关系（BMW is a car）；包含且实现 子类通用特性，子类存在差异化的特性抽象，交给子类实现
   - 接口：**对行为的抽象**， `like a` 关系（Bird like a Aircraft 可以飞），本质上 `is a bird`；
     - 定义行为，实现类 *做* 什么；实现类主题是谁，如何实现，接口不关心
2. 抽象类和接口 - 区别
   - **接口** 是公开的，不能有私有的方法或变量，接口中的所有方法都 `没有方法体`，通过关键字 `interface` 实现。
   - **抽象类** 是可以有私有方法或私有变量的，通过把类或者类中的方法声明为`abstract`来表示一个类是抽象类，被声明为抽象的方法 `不能包含方法体`。
3. 抽象类和接口 - 相同点
   - 都不能被实例化
   - 接口的实现类或抽象类的子类都只有 *实现了接口或抽象类中的方法后才能实例化*。
4. 抽象类和接口 - 不同点
   - 接口只有定义，不能有方法的实现，java 1.8中可以定义 `default` 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
   - 实现接口的关键字为 `implements`，继承抽象类的关键字为 `extends`。**一个类可以实现多个接口**，但**一个类只能继承一个抽象类**。所以，使用接口可以间接地实现多重继承。
   - 接口强调 **特定功能** 的实现，而抽象类强调 **所属关系**。
   - **接口**成员变量默认为 `public static final`，必须赋初值，不能被修改；其所有的成员方法都是 `public`、`abstract` 的。抽象类中成员变量默认 `default`，可在子类中被重新定义，也可被重新赋值；
   - **抽象**方法被 `abstract` 修饰，不能被`private`、`static`、`synchronized` 和 `native` 等修饰，必须以分号结尾，不带花括号。
   - 接口被用于常用的功能，便于日后维护和添加删除，而**抽象类更倾向于充当公共类的角色**，不适用于日后重新对里面的代码修改。**功能需要累积** 时用抽象类，不需要累积时用接口。



## Exception

- Checked Exception
  - Checked exceptions are **checked at compile-time**.
    - **编译器**要检查这类异常
    - 必须处理（try ...catch）的异常
  - Example: `IOException`, `SQLException` etc.
- Unchecked Exception （Runtime Exception）
  - The classes that **extend `RuntimeException`** are known as unchecked exceptions. 
  - Unchecked exceptions are **not checked at compile-time**.
  - Example: `ArithmeticException`, `NullPointerException` etc.



## Processes (进程) and Threads (线程) 

|                   | **Process**                                                  | **Thread**                                                   |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Definition**    | An executing **instance of a program** is called a process.  | A thread is a **subset of the process**.                     |
| **Communication** | Processes must use inter-process communication to communicate with sibling processes. | Threads can directly communicate with other threads of its process. |
| **Control**       | Processes can only exercise control over child processes.    | Threads can exercise considerable control over threads of the same process. |
| **Changes**       | Any change in the parent process does not affect child processes. | Any change in the main thread may affect the behavior of the other threads of the process. |
| **Memory**        | Run in separate memory spaces.                               | Run in **shared memory spaces**.                             |
| **Controlled by** | Process is controlled by the operating system.               | Threads are controlled by programmer in a program.           |
| **Dependence**    | Processes are independent.                                   | Threads are dependent.                                       |



# Spring



## Spring

- 什么是Spring?
  - Spring是一个轻量级的IoC和AOP容器框架
- 什么是MVC模式?
  - 设计模式，是spring在原有基础上，又提供了web应用的MVC模块，
  - ![image-20220430121024798](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220430121024798.png)
- SpringMVC常用的注解有哪些？
  - @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中
    的所有响应请求的方法都是以该地址作为父路径。
  - @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
  - @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。



## IOC

- IOC就是控制反转，是指创建对象的控制权的转移
  - 以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。
  - 应用程序在运行时依赖IoC容器来 *动态注入对象需要的外部资源*
- IOC让对象的创建不用去new了，可以 *由spring自动生产*，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的
- Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入

> *IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。*



## AOP

- Aspect-Oriented Programming，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来
  - 减少系统的重复代码
  - 降低模块间的耦合度
  - 可扩展性和可维护性
- 基于动态代理



## Spring依赖注入有哪几种方式

- [Spring依赖注入有哪几种方式](https://www.zhihu.com/question/452470872)
- Constructor-based
  - [Spring Boot简明教程--依赖注入的三种方式](https://cloud.tencent.com/developer/article/1777778)
  - ![image-20220430124836919](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220430124836919.png)
- Field
  - 接口注入 依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。
  - 优点 接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。
  - 缺点： 侵入行太强，不建议使用。
- ![image-20220429225558031](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220429225558031.png)
- ![image-20220429230709603](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220429230709603.png)



## 事务的隔离级别

- [MySQL事务之不可重复读问题](https://blog.csdn.net/sun8112133/article/details/89739475)
- 未提交读(Read Uncommitted)：允许脏读，一个事务可以读取另一个未提交事务的数据。最低级别，它存在4个常见问题（[脏读](https://so.csdn.net/so/search?q=脏读&spm=1001.2101.3001.7020)、不可重复读、幻读、丢失更新）
- 提交读(Read Committed)：只能读取到已经提交的数据。一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在3个常见问题（不可重复读、幻读、丢失更新）
- 可重复读(Repeated Read)：开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在2个常见问题（幻读、丢失更新）
- 可串行化(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用
- ![image-20220430130914236](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220430130914236.png)
- **脏读 (dirty read)**
  - 一个事务，读取了另一个事务，没有提交的数据。 (读了别人的)
- **不可重复读 (unrepeatable read)**
  - 就是一个事务读到另一个事务修改后并提交的数据（update）。在同一个事务中，对于同一组数据读取到的结果不一致。比如，事务B 在 事务A 提交前读到的结果，和在 事务A 提交后读到的结果可能不同。不可重复读出现的原因就是由于事务并发修改记录而导致的。
- **幻读（虚读）(phantom read)**
  - 在一个事务内，读取到了别的事务插入的数据，导致前后读取不一致。（读自己的，别人插入我）











SELECT id, customer_name FROM customer where id NOT IN (SELECT customer_id FROM invoice)

UNION

SELECT id, product_name FROM product where is NOT IN (SELECT product_id FROM invoice_item );



