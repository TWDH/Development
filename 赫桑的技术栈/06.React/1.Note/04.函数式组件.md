# 1. 创建函数式组件

- React 解析组件标签，找到了`MyComponent`组件。
  - 注意首字母大写！
  - 标签自闭和！
- 发现组件是使用**函数定义**的，随后调用该函数 `<MyComponent/>`，将返回的虚拟 DOM 转为真实DOM，随后呈现在页面中。

- ```react
  <body>
      <!-- 准备好一个“容器” -->
      <div id="test"></div>
  
      <!-- 引入react核心库 -->
      <script type="text/javascript" src="../js/react.development.js"></script>
      <!-- 引入react-dom，用于支持react操作DOM -->
      <script type="text/javascript" src="../js/react-dom.development.js"></script>
      <!-- 引入babel，用于将jsx转为js -->
      <script type="text/javascript" src="../js/babel.min.js"></script>
  
      <script type="text/babel">
  		// 1.创建函数式组件
  		function MyComponent(){
  			console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式
  			return <h2>我是用函数定义的组件 (适用于【简单组件】的定义)</h2>
  		}
  		
  		// 2.渲染组件到页面
  		ReactDOM.render(<MyComponent/>, document.getElementById('test'))
      </script>
  </body>
  ```

# 2.类式组件

- ![image-20220114170129115](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114170129115.png)
- render 是放在哪里的？
  - `MyComponent`的原型对象上，供实例使用。
  - 组件标签 `<MyComponent/>`，react 自动新建一个对象
- render 中的 **this** 是谁？
  - `MyComponent` 的实例对象  <=> `MyComponent`组件实例对象。

### 2.1 执行了ReactDOM.render(`<MyComponent/>`.......) 之后，发生了什么？

1. React 解析组件标签，找到了`MyComponent`组件。
2. React 发现组件是使用 **类** 定义的，随后 `new` 出来 **该类的实例**，并 **通过该实例调用到原型上的 render 方法**。
3. 将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。

- ```react
  <body>
      <!-- 准备好一个“容器” -->
      <div id="test"></div>
  
      <!-- 引入react核心库 -->
      <script type="text/javascript" src="../js/react.development.js"></script>
      <!-- 引入react-dom，用于支持react操作DOM -->
      <script type="text/javascript" src="../js/react-dom.development.js"></script>
      <!-- 引入babel，用于将jsx转为js -->
      <script type="text/javascript" src="../js/babel.min.js"></script>
  
      <script type="text/babel">
          
          // 1.创建类式组件
          class MyComponent extends React.Component {
              render(){
                  //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。
                  //render中的this是谁？—— MyComponent的实例对象 <=> MyComponent组件实例对象。
                  console.log('render中的this:', this);
                  return <h2>我是用类定义的组件(适用于【复杂组件】的定义)</h2>
              }
          }
          
          // 2.渲染组件到页面
          ReactDOM.render(<MyComponent/>, document.getElementById('test'))
      </script>
  </body>
  ```



- 函数式组件：
  - 无状态 State 
  - <img src="https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114181516261.png" alt="image-20220114181516261" style="zoom:150%;" />
  - ![image-20220114181753702](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114181753702.png)
- 类式组件：
  - 有状态 State
  - **把数据放在组件的状态中，更改状态的数据，可以引起虚拟 DOM 的变化**
    - 需要使用 `setState()`
  - <img src="https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114181529383.png" alt="image-20220114181529383" style="zoom:150%;" />

## 2.2 组件实例三大核心属性1: state

- ![image-20220114190403521](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114190403521.png)

### 2.2.1. 效果

- 需求:  定义一个展示天气信息的组件
  1. *默认展示天气炎热* *或* *凉爽*
  2. *点击文字切换天气*

### 2.2.2. 理解

1. `state` 是组件对象最重要的属性, 值是对象(可以包含多个 key-value 的组合)
2. 组件被称为 "状态机",  通过更新组件的 state 来更新对应的页面显示 (重新渲染组件)

### 2.2.3. 强烈注意

1. 组件中 render 方法中的 `this` 为组件实例对象
2. 组件自定义的方法中 `this` 为 `undefined`，如何解决？
   1. 强制绑定 `this`: 通过函数对象的`bind()`
   2. 箭头函数
3. 状态数据，不能直接修改或更新

### # 代码示例

- ### `changeWeather`放在哪里？

  - `Weather`的原型对象上，供实例使用

- ！！！ 通过 `Weather` 实例调用 `changeWeather` 时，`changeWeather` 中的 `this` 就是 `Weather` **实例** ！！！

  - 类内的方法调用，一定是 `this.func`调用

- 由于`changeWeather`是作为`onClick`的回调，所以**不是通过实例调用**的，是**直接调用**；所以`this` 不起效

- 类中的方法默认开启了**局部的严格模式**，所以`changeWeather`中的`this`为`undefined`

- ###  **解决`changeWeather`中`this`指向问题**

  - `this.changeWeather = this.changeWeather.bind(this);`
  - 调用时，是**实例自身的 changeWeather**；而不是**原型链中的 changeWeather**
  - 原型链中的 changeWeather 不能删，因为是用其产生的**实例自身的 changeWeather**
  - ![image-20220114200855586](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114200855586.png)

- ### render 调用几次？

  - `1 + n` 次 1是初始化的那次 
  - `n`是状态更新的次数
  - **每次 state 更改一次，render 就调用一次**

- ### **bind**

  1. 生成一个新的函数
  2. 改变函数的 `this`，`this.changeWeather.bind(this)` 
     - 将 `changeWeather` 中的 `this`，改为 `Constructor` 的 `this`（**Weather的实例对象**）

- ### this.setState()

  - 更改状态，需要使用API：`this.setState()`； `setState` 在原型链的底端，使用 this 可以直接找到
  - 需要**指定哪个属性**（isHot）：`this.setState({ isHot: !isHot });`
  - `setState()`：状态必须通过 setState 进行更新,且 **更新是一种合并，不是替换**。
  - 状态不可直接更改

- ```react
  <body>
      <!-- 准备好一个“容器” -->
      <div id="test"></div>
  
      <!-- 引入react核心库 -->
      <script type="text/javascript" src="../js/react.development.js"></script>
      <!-- 引入react-dom，用于支持react操作DOM -->
      <script
          type="text/javascript"
          src="../js/react-dom.development.js"
          ></script>
      <!-- 引入babel，用于将jsx转为js -->
      <script type="text/javascript" src="../js/babel.min.js"></script>
  
      <script type="text/babel">
          //1.创建组件
          class Weather extends React.Component {
              // 构造器调用几次？ ———— 1次
              constructor(props) {
                  console.log("constructor");
                  super(props);
                  //初始化状态
                  this.state = { isHot: false, wind: "微风" };
                  //解决changeWeather中this指向问题
                  this.changeWeather = this.changeWeather.bind(this);
              }
  
              // render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
              render() {
                  console.log("render");
                  //读取状态
                  const { isHot, wind } = this.state;
                  return (
                      <h1 onClick={this.changeWeather}>
                          今天天气很{isHot ? "炎热" : "凉爽"}，{wind}
                      </h1>
                  );
              }
  
              //changeWeather调用几次？ ———— 点几次调几次
              changeWeather() {
                  //changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
                  //由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
                  //类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
  
                  console.log("changeWeather");
                  //获取原来的isHot值
                  const isHot = this.state.isHot;
                  //严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
                  this.setState({ isHot: !isHot });
                  console.log(this);
  				
                  //严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
                  //this.state.isHot = !isHot //这是错误的写法
              }
          }
          
          // 2.渲染组件到页面
          ReactDOM.render(<Weather/>, document.getElementById("test"));
      </script>
  </body>
  ```

- ![image-20220114192539648](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220114192539648.png)



## 2.3 











































































