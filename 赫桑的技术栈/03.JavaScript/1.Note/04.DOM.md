# 04.DOM

![image-20211205151301736](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211205151301736.png)

# 1、DOM简介

## 1.1、什么是DOM

- 文档对象模型（`Document Object Model`，简称 `DOM`），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准**编程接口**
- W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的**内容**、**结构**和**样式**。
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/fc42557d25be4683881c2f0f231bc778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

- 文档：一个页面就是一个文档，DOM中使用 doucument 来表示
- 元素：页面中的所有标签都是元素，DOM中使用 `element` 表示
- 节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示

**DOM 把以上内容都看做是==对象==**

# 2、获取元素

## 2.1、如何获取页面元素

1. DOM在我们实际开发中主要用来操作元素。
2. 获取页面中的元素可以使用以下几种方式:
   1. 根据 ID 获取
   2. 根据标签名获取
   3. 通过 HTML5 新增的方法获取
   4. 特殊元素获取

## 2.2、根据ID获取

- 使用 `getElementByld()` 方法可以获取带ID的元素对象

  - ```js
    doucument.getElementByld('id名')
    ```

- ```js
  <div id="time">2019-9-9</div>
  
  <script>
      // 1.因为我们文档页面从上往下加载，所以得先有标签，所以script写在标签下面
      // 2.get 获得 element 元素 by 通过 驼峰命名法
      // 3.参数 id是大小写敏感的字符串
      // 4.返回的是一个元素(Element)对象
      var timer = document.getElementById('time');
      console.log(timer);
      // 5. console.dir 打印我们的元素对象，更好的查看里面的属性和方法
      console.dir(timer);
  </script>
  ```

## 2.3、根据标签名获取

- 根据**标签名**获取，使用 `getElementByTagName()` 方法可以返回带有指定标签名的**对象的集合**

  - ```js
    doucument.getElementsByTagName('标签名');
    ```

- 因为得到的是一个**对象的集合**，所以我们想要操作里面的元素就需要遍历

- 得到元素对象是动态的

- 返回的是获取过来**元素对象的集合**，以**伪数组**的形式存储

- 如果**获取不到元素**，则返回为**空的伪数组**(因为获取不到对象)

  - ```js
    <ul>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
    </ul>
    <script>
        // 1.返回的是获取过来元素对象的集合 以伪数组的形式存储
        var lis = document.getElementsByTagName('li');
        console.log(lis);
        console.log(lis[0]);
        // 2.依次打印,遍历
        for (var i = 0; i < lis.length; i++) {
            console.log(lis[i]);
        }
        // 3.如果页面中只有 1 个 li，返回的还是伪数组的形式
        // 4.如果页面中没有这个元素，返回的是空伪数组
    </script>
    ```

## 2.4、根据标签名获取

- 还可以根据**标签名**获取某个元素（父元素）内部所有指定标签名的子元素,获取的时候不包括父元素自己

  - ```js
    element.getElementsByTagName('标签名')
    
    ol.getElementsByTagName('li');
    ```

- 注意：**父元素**必须是**单个对象**(**必须指明是哪一个元素对象**)，获取的时候不包括父元素自己

  - ```js
    <script>
    	//element.getElementsByTagName('标签名'); 父元素必须是指定的单个元素
        var ol = document.getElementById('ol');
        console.log(ol.getElementsByTagName('li'));
    </script>
    ```

## 2.5、通过H5新增方法获取

### ① `getElementsByClassName`

- 根据**类名**返回元素对象合集

  - ```js
    document.getElementsByClassName('类名')
    ```

### ② `document.querySelector`

- 根据**指定选择器**返回**第一个元素对象**

  - `class` 类选择器: `document.querySelector('.box');`
    
  - `id`选择器:  `document.querySelector('#id');`
    
  - ```js
    document.querySelector('选择器');
    
    // 切记里面的选择器需要加符号 
    // 类选择器.box 
    // id选择器 #nav
    var firstBox = document.querySelector('.box');
    ```
    

### ③ `document.querySelectorAll`

- 根据指定选择器返回所有元素对象

  - ```js
    document.querySelectorAll('选择器');
    ```

- 注意：

  - `querySelector` 和 `querySelectorAll` 里面的选择器需要加符号,比如:
  - **`document.querySelector('#nav');`**

### ④ 例子

- ```js
  <script>
      // 1. getElementsByClassName 根据类名获得某些元素集合
      var boxs = document.getElementsByClassName('box');
      console.log(boxs);
      // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav
      var firstBox = document.querySelector('.box');
      console.log(firstBox);
      var nav = document.querySelector('#nav');
      console.log(nav);
      var li = document.querySelector('li');
      console.log(li);
      // 3. querySelectorAll()返回指定选择器的所有元素对象集合
      var allBox = document.querySelectorAll('.box');
      console.log(allBox);
      var lis = document.querySelectorAll('li');
      console.log(lis);
  </script>
  ```

## 2.6、获取特殊元素

### ① 获取body元素

- 返回 `body` 元素对象

  - ```js
    document.body;
    ```

### ② 获取html元素

- 返回`html`元素对象

  - ```js
    document.documentElement;
    ```

# 3、事件基础

## 3.1、事件概述

- JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。
- 简单理解： 触发— 响应机制。
- 网页中的**每个元素**都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。

## 3.2、事件三要素

1. 事件源 (谁)
   - 按钮 (`'btn'`)
2. 事件类型 (什么事件)
   - `onclick`
3. 事件处理程序 (做啥)
   - 函数

```js
<script>
    // 点击一个按钮，弹出对话框
    //  1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素
    // (1) 事件源 事件被触发的对象   谁  按钮
    var btn = document.getElementById('btn');
    // (2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下
    // (3) 事件处理程序  通过一个函数赋值的方式 完成
    btn.onclick = function() {
        alert('点秋香');
    }
</script>
```

## 3.3、执行事件的步骤

1. 获取事件源
2. 注册事件(绑定事件)
3. 添加事件处理程序(采取函数赋值形式)

```js
<script>
    // 执行事件步骤
    // 点击div 控制台输出 我被选中了
    // 1. 获取事件源
    var div = document.querySelector('div');
    // 2.绑定事件 注册事件
    // div.onclick 
    // 3.添加事件处理程序 
    div.onclick = function() {
        console.log('我被选中了');
    }
</script>
```

## 3.4、鼠标事件

- ![image-20211206142809047](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211206142809047.png)

# 4、操作元素

- JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性

## 4.1、改变元素内容

### # `innerText`

- 从起始位置到终止位置的内容，但它**去除不识别`html`标签**，同时空格和换行也会去掉

  - ```js
    element.innerText
    ```


### # `innerHTML` 重点

- 起始位置到终止位置的全部内容，包括`HTML`标签，同时保留空格和换行

  - ```js
    element.innerHTML
    ```

- ```js
  <body>
      <div></div>
      <p>
          我是文字
          <span>123</span>
      </p>
  
      <script>
          // innerText 和 innerHTML的区别 
          // 1. innerText 不识别html标签,去除空格和换行
          var div = document.querySelector('div');
          div.innerText = '<strong>今天是：</strong> 2019';
          // 2. innerHTML 识别html标签 保留空格和换行的
          div.innerHTML = '<strong>今天是：</strong> 2019';
          // 这两个属性是可读写的  可以获取元素里面的内容
          var p = document.querySelector('p');
          console.log(p.innerText);
          console.log(p.innerHTML);
      </script>
  </body>
  
  ```

- ![img](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/f3394f40561e45c299c09d7bbecdb513.png)

## 4.2、改变元素属性

- ```js
  // img.属性
  img.src = "xxx";
  
  input.value = "xxx";
  input.type = "xxx";
  input.checked = "xxx";
  input.selected = true / false;
  input.disabled = true / false;
  ```
  
- ```js
  <body>
      <button id="ldh">刘德华</button>
      <button id="zxy">张学友</button> <br>
      <img src="images/ldh.jpg" alt="" title="刘德华">
  
      <script>
          // 修改元素属性  src
          // 1. 获取元素
          var ldh = document.getElementById('ldh');
          var zxy = document.getElementById('zxy');
          var img = document.querySelector('img');
          // 2. 注册事件  处理程序
          zxy.onclick = function() {
              img.src = 'images/zxy.jpg';
              img.title = '张学友思密达';
          }
          ldh.onclick = function() {
              img.src = 'images/ldh.jpg';
              img.title = '刘德华';
          }
      </script>
  </body>
  ```

- ![image-20211206161549351](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211206161549351.png)

### # 分时问候语案例

- ```js
  <body>
      <img src="images/s.gif" alt="">
      <div>上午好</div>
      <script>
          // 根据系统不同时间来判断，所以需要用到日期内置对象
          // 利用多分支语句来设置不同的图片
          // 需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性
          // 需要一个div元素，显示不同问候语，修改元素内容即可
          // 1.获取元素
          var img = document.querySelector('img');
          var div = document.querySelector('div');
          // 2. 得到当前的小时数
          var date = new Date();
          var h = date.getHours();
          // 3. 判断小时数改变图片和文字信息
          if (h < 12) {
              img.src = 'images/s.gif';
              div.innerHTML = '亲，上午好，好好写代码';
          } else if (h < 18) {
              img.src = 'images/x.gif';
              div.innerHTML = '亲，下午好，好好写代码';
          } else {
              img.src = 'images/w.gif';
              div.innerHTML = '亲，晚上好，好好写代码';
  
          }
      </script>
  </body>
  ```

### # 操作表单之表单属性设置

- `input.innerHTML = '点击了';`  这个是 **普通盒子** 比如 `div` 标签里面的内容

- **表单**里面的值 文字内容是通过 `value` 来修改的

- 如果想要某个**表单被禁用** 不能再点击 `disabled`  我们想要这个按钮 **button禁用**

  - `btn.disabled = true;`
  - `this.disabled = true;`   this 指向的是**事件函数的调用者 btn**

- ```js
  <body>
      <button>按钮</button>
      <input type="text" value="输入内容">
      <script>
          // 1. 获取元素
          var btn = document.querySelector('button');
          var input = document.querySelector('input');
          // 2. 注册事件 处理程序
          btn.onclick = function() {
              // input.innerHTML = '点击了';  这个是 普通盒子 比如 div 标签里面的内容
              // 表单里面的值 文字内容是通过 value 来修改的
              input.value = '被点击了';
              // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用
              btn.disabled = true;
              this.disabled = true;
              // this 指向的是事件函数的调用者 btn
          }
      </script>
  </body>
  ```

### # 显示隐藏密码 - 睁眼睛

- ```js
  <body>
      <div class="box">
          <label for="">
              <img src="images/close.png" alt="" id="eye">
          </label>
          <input type="password" name="" id="pwd">
      </div>
      <script>
          // 1. 获取元素
          var eye = document.getElementById('eye');
          var pwd = document.getElementById('pwd');
          // 2. 注册事件 处理程序
          var flag = 0;
          eye.onclick = function() {
              // 点击一次之后， flag 一定要变化
              if (flag == 0) {
                  pwd.type = 'text';
                  eye.src = 'images/open.png';
                  flag = 1; // 赋值操作
              } else {
                  pwd.type = 'password';
                  eye.src = 'images/close.png';
                  flag = 0;
              }
          }
      </script>
  </body>
  ```

- ![image-20211206165239497](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211206165239497.png)   

## 4.3、改变样式属性 （style， className）

我们可以通过 JS 修改元素的**大小、颜色、位置**等样式。

- **行内样式**操作

  - ```js
    element.style
    ```

- **类名样式**操作

  - ```js
    element.className
    ```

### 案例

- ```js
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              width: 200px;
              height: 200px;
              background-color: pink;
          }
      </style>
  </head>
  
  <body>
      <div></div>
      <script>
          // 1. 获取元素
          var div = document.querySelector('div');
          // 2. 注册事件 处理程序
          div.onclick = function() {
              // div.style里面的属性 采取驼峰命名法 
              this.style.backgroundColor = 'purple';
              this.style.width = '250px';
          }
      </script>
  </body>
  ```

- ![image-20211206170236180](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211206170236180.png)

- ![image-20211206170245892](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211206170245892.png)

### # 淘宝关闭二维码

- `display: none` 隐藏元素

- `display:block` 显示元素

- ```js
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          .box {
              position: relative;
              width: 74px;
              height: 88px;
              border: 1px solid #ccc;
              margin: 100px auto;
              font-size: 12px;
              text-align: center;
              color: #f40;
              /* display: block; */
          }
          
          .box img {
              width: 60px;
              margin-top: 5px;
          }
          
          .close-btn {
              position: absolute;
              top: -1px;
              left: -16px;
              width: 14px;
              height: 14px;
              border: 1px solid #ccc;
              line-height: 14px;
              font-family: Arial, Helvetica, sans-serif;
              cursor: pointer;
          }
      </style>
  </head>
  
  <body>
      <div class="box">
          淘宝二维码
          <img src="images/tao.png" alt="">
          <i class="close-btn">×</i>
      </div>
      <script>
          // 1. 获取元素 
          var btn = document.querySelector('.close-btn');
          var box = document.querySelector('.box');
          // 2.注册事件 程序处理
          btn.onclick = function() {
              box.style.display = 'none';
          }
      </script>
  </body>
  ```

- ![image-20211206172656360](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211206172656360.png)

### # 循环精灵图

- 竖版精灵图

- ```js
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          * {
              margin: 0;
              padding: 0;
          }
          
          li {
              list-style-type: none;
          }
          
          .box {
              width: 250px;
              margin: 100px auto;
          }
          
          .box li {
              float: left;
              width: 24px;
              height: 24px;
              background-color: pink;
              margin: 15px;
              background: url(images/sprite.png) no-repeat;
          }
      </style>
  </head>
  <body>
      <div class="box">
          <ul>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
              <li></li>
          </ul>
      </div>
      <script>
          // 1. 获取元素 所有的小li 
          var lis = document.querySelectorAll('li');
          for (var i = 0; i < lis.length; i++) {
              // 让索引号 乘以 44 就是每个li 的背景y坐标  index就是我们的y坐标
              var index = i * 44;
              lis[i].style.backgroundPosition = '0 -' + index + 'px';
          }
      </script>
  </body>
  ```

- ![image-20211207105355887](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207105355887.png)

- ![sprite](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/sprite.png)

### # 显示隐藏文本框内容

- 获取焦点：`text.onfocus = function() {}`

- 失去焦点：`text.onblur = function() {}`

- ```js
  <body>
      <input type="text" value="手机">
      <script>
          // 1.获取元素
          var text = document.querySelector('input');
          // 2.注册事件 获得焦点事件 onfocus 
          text.onfocus = function() {
                  // console.log('得到了焦点');
                  if (this.value === '手机') {
                      this.value = '';
                  }
                  // 获得焦点需要把文本框里面的文字颜色变黑
                  this.style.color = '#333';
              }
              // 3. 注册事件 失去焦点事件 onblur
          text.onblur = function() {
              // console.log('失去了焦点');
              if (this.value === '') {
                  this.value = '手机';
              }
              // 失去焦点需要把文本框里面的文字颜色变浅色
              this.style.color = '#999';
          }
      </script>
  
  </body>
  ```

- ![image-20211207111258712](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207111258712.png)

- `placeholder` 有同样效果

### # 通过`className`更改元素样式（重点）

- 通过给 `class` 赋值，改变样式

  - `this.className = 'change';`

- 如果当前 div 原来有一个类名 `first`，想再加入类名 `change`，需要把这两个一起写上

  - `this.className = 'first change';`

- ```js
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              width: 100px;
              height: 100px;
              background-color: pink;
          }
          
          .change {
              background-color: purple;
              color: #fff;
              font-size: 25px;
              margin-top: 100px;
          }
      </style>
  </head>
  
  
  <body>
      <div class="first">文本</div>
      <script>
          // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用
          var test = document.querySelector('div');
          test.onclick = function() {
              // 让我们当前元素的类名改为了 change
  
              // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
              // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
              // this.className = 'change';
              this.className = 'first change';
          }
      </script>
  </body>
  ```

### # 仿新浪注册页面

- 密码提示信息

- 首先判断的事件是表单失去焦点 `onblur`

- 如果输入正确则提示正确的信息颜色为绿色小图标变化

- 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化

- 因为里面变化样式较多，我们采取`className`修改样式

- ```js
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              width: 600px;
              margin: 100px auto;
          }
          
          .message {
              display: inline-block;
              font-size: 12px;
              color: #999;
              background: url(images/mess.png) no-repeat left center;
              padding-left: 20px;
          }
          
          .wrong {
              color: red;
              background-image: url(images/wrong.png);
          }
          
          .right {
              color: green;
              background-image: url(images/right.png);
          }
      </style>
  </head>
  
  <body>
      <div class="register">
          <input type="password" class="ipt">
          <p class="message">请输入6~16位密码</p>
      </div>
      <script>
          // 1.获取元素
          var ipt = document.querySelector('.ipt');
          var message = document.querySelector('.message');
          //2. 注册事件 失去焦点
          ipt.onblur = function() {
              // 根据表单里面值的长度 ipt.value.length
              if (this.value.length < 6 || this.value.length > 16) {
                  message.className = 'message wrong';
                  message.innerHTML = '您输入的位数不对要求6~16位';
              } else {
                  message.className = 'message right';
                  message.innerHTML = '您输入的正确';
              }
          }
      </script>
  </body>
  ```

- 

### 注意：

1. JS里面的样式采取驼峰命名法，比如 `fontSize` ，`backgroundColor`
2. JS 修改 `style` 样式操作 ，产生的是行内样式，CSS权重比较高
3. 如果样式修改较多，可以采取操作类名方式更改元素样式
4. `class` 因为是个保留字，因此使用`className`来操作元素类名属性
5. `className` 会**直接更改元素的类名**，会**覆盖原先的类名**

```js
<body>
    <div class="first">文本</div>
    <script>
        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用
        var test = document.querySelector('div');
        test.onclick = function() {
            // this.style.backgroundColor = 'purple';
            // this.style.color = '#fff';
            // this.style.fontSize = '25px';
            // this.style.marginTop = '100px';
            // 让我们当前元素的类名改为了 change

            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
            // this.className = 'change';
            this.className = 'first change';
        }
    </script>
</body>
```

## 4.4、总结

- ![在这里插入图片描述](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/f6835ead437948e3804c4432ceb812ad.png)


## 4.5、排他思想

如果有同一组元素，我们相要某一个元素实现某种样式，需要用到循环的排他思想算法：

1. **所有元素全部清除样式**（干掉其他人）
2. 给当前元素设置样式 （留下我自己）
3. 注意顺序不能颠倒，首先干掉其他人，再设置自己



- 不能用`btns[i]`是因为当 for 循环绑定完五个按钮结束循环后 i里面存的值是5，这时候再运行被绑定的代码块的时候就相当于`btn[5].style` 所以会出现错误

- 因为这里要给每一个button对象操作，让他们的背景颜色取消，而this只能指向当前调用函数

- ```html
  <body>
      <button>按钮1</button>
      <button>按钮2</button>
      <button>按钮3</button>
      <button>按钮4</button>
      <button>按钮5</button>
  
      <script>
          // 1. 获取所有按钮元素
          var btns = document.getElementsByTagName('button');
      // btns得到的是伪数组  里面的每一个元素 btns[i]
      for (var i = 0; i < btns.length; i++) {
          btns[i].onclick = function() {
              // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人
              for (var i = 0; i < btns.length; i++) {
                  btns[i].style.backgroundColor = '';
              }
              // (2) 然后才让当前的元素背景颜色为pink 留下我自己
              this.style.backgroundColor = 'pink';
  
          }
      }
      //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想
      </script>
  </body>
  ```

- ![image-20211207121134504](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207121134504.png)

### # 百度换肤效果

- `this.src` 就是我们点击图片的路径

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          * {
              margin: 0;
              padding: 0;
          }
  
          body {
              background: url(images/1.jpg) no-repeat center top;
          }
  
          li {
              list-style: none;
          }
  
          .baidu {
              overflow: hidden;
              margin: 100px auto;
              background-color: #fff;
              width: 410px;
              padding-top: 3px;
          }
  
          .baidu li {
              float: left;
              margin: 0 1px;
              cursor: pointer;
          }
  
          .baidu img {
              width: 100px;
          }
      </style>
  </head>
  
  <body>
      <ul class="baidu">
          <li><img src="images/1.jpg"></li>
          <li><img src="images/2.jpg"></li>
          <li><img src="images/3.jpg"></li>
          <li><img src="images/4.jpg"></li>
      </ul>
      <script>
          // 1. 获取元素 
          var imgs = document.querySelector('.baidu').querySelectorAll('img');
          // console.log(imgs);
          // 2. 循环注册事件 
          for (var i = 0; i < imgs.length; i++) {
              imgs[i].onclick = function() {
                  // this.src 就是我们点击图片的路径   images/2.jpg
                  // 把这个路径 this.src 给body 就可以了
                  document.body.style.backgroundImage = 'url(' + this.src + ')';
              }
          }
      </script>
  </body>
  ```

- ![image-20211207123619244](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207123619244.png)



### # 表格隔行变色

- 鼠标经过：`onmouseover`

- 鼠标离开：`onmouseout`

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          table {
              width: 800px;
              margin: 100px auto;
              text-align: center;
              border-collapse: collapse;
              font-size: 14px;
          }
          
          thead tr {
              height: 30px;
              background-color: skyblue;
          }
          
          tbody tr {
              height: 30px;
          }
          
          tbody td {
              border-bottom: 1px solid #d7d7d7;
              font-size: 12px;
              color: blue;
          }
          
          .bg {
              background-color: pink;
          }
      </style>
  </head>
  
  <body>
      <table>
          <thead>
              <tr>
                  <th>代码</th>
                  <th>名称</th>
                  <th>最新公布净值</th>
                  <th>累计净值</th>
                  <th>前单位净值</th>
                  <th>净值增长率</th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>003526</td>
                  <td>农银金穗3个月定期开放债券</td>
                  <td>1.075</td>
                  <td>1.079</td>
                  <td>1.074</td>
                  <td>+0.047%</td>
              </tr>
              <tr>
                  <td>003526</td>
                  <td>农银金穗3个月定期开放债券</td>
                  <td>1.075</td>
                  <td>1.079</td>
                  <td>1.074</td>
                  <td>+0.047%</td>
              </tr>
              <tr>
                  <td>003526</td>
                  <td>农银金穗3个月定期开放债券</td>
                  <td>1.075</td>
                  <td>1.079</td>
                  <td>1.074</td>
                  <td>+0.047%</td>
              </tr>
              <tr>
                  <td>003526</td>
                  <td>农银金穗3个月定期开放债券</td>
                  <td>1.075</td>
                  <td>1.079</td>
                  <td>1.074</td>
                  <td>+0.047%</td>
              </tr>
              <tr>
                  <td>003526</td>
                  <td>农银金穗3个月定期开放债券</td>
                  <td>1.075</td>
                  <td>1.079</td>
                  <td>1.074</td>
                  <td>+0.047%</td>
              </tr>
              <tr>
                  <td>003526</td>
                  <td>农银金穗3个月定期开放债券</td>
                  <td>1.075</td>
                  <td>1.079</td>
                  <td>1.074</td>
                  <td>+0.047%</td>
              </tr>
          </tbody>
      </table>
      <script>
          // 1.获取元素 获取的是 tbody 里面所有的行
          var trs = document.querySelector('tbody').querySelectorAll('tr');
          // 2. 利用循环绑定注册事件
          for (var i = 0; i < trs.length; i++) {
              // 3. 鼠标经过事件 onmouseover
              trs[i].onmouseover = function() {
                      // console.log(11);
                      this.className = 'bg';
                  }
                  // 4. 鼠标离开事件 onmouseout
              trs[i].onmouseout = function() {
                  this.className = '';
              }
          }
      </script>
  </body>
  ```

- ![image-20211207124117066](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207124117066.png)

### # 全选 & 反选

- **全选**和**取消全选**做法：让下面所有复选框的`checked`属性（选中状态） 跟随全选按钮即可

- 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。

- ```html
  <html>
    <head lang="en">
      <meta charset="UTF-8" />
      <title></title>
      <style>
        * {
          padding: 0;
          margin: 0;
        }
  
        .wrap {
          width: 300px;
          margin: 100px auto 0;
        }
  
        table {
          border-collapse: collapse;
          border-spacing: 0;
          border: 1px solid #c0c0c0;
          width: 300px;
        }
  
        th,
        td {
          border: 1px solid #d0d0d0;
          color: #404060;
          padding: 10px;
        }
  
        th {
          background-color: #09c;
          font: bold 16px "微软雅黑";
          color: #fff;
        }
  
        td {
          font: 14px "微软雅黑";
        }
  
        tbody tr {
          background-color: #f0f0f0;
        }
  
        tbody tr:hover {
          cursor: pointer;
          background-color: #fafafa;
        }
      </style>
    </head>
  
    <body>
      <div class="wrap">
        <table>
          <thead>
            <tr>
              <th>
                <input type="checkbox" id="j_cbAll" />
              </th>
              <th>商品</th>
              <th>价钱</th>
            </tr>
          </thead>
          <tbody id="j_tb">
            <tr>
              <td>
                <input type="checkbox" />
              </td>
              <td>iPhone8</td>
              <td>8000</td>
            </tr>
            <tr>
              <td>
                <input type="checkbox" />
              </td>
              <td>iPad Pro</td>
              <td>5000</td>
            </tr>
            <tr>
              <td>
                <input type="checkbox" />
              </td>
              <td>iPad Air</td>
              <td>2000</td>
            </tr>
            <tr>
              <td>
                <input type="checkbox" />
              </td>
              <td>Apple Watch</td>
              <td>2000</td>
            </tr>
          </tbody>
        </table>
      </div>
  
      <script>
        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可
        // 获取元素
        var j_cbAll = document.getElementById("j_cbAll"); // 全选按钮
        var j_tbs = document.getElementById("j_tb").getElementsByTagName("input"); // 下面所有的复选框
        // 注册事件
        j_cbAll.onclick = function () {
          // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中
          console.log(this.checked);
          for (var i = 0; i < j_tbs.length; i++) {
            // checked 属性
            j_tbs[i].checked = this.checked;
          }
        };
          
        // 2. 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，
        // 每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的，上面全选就不选中。
        for (var i = 0; i < j_tbs.length; i++) {
          j_tbs[i].onclick = function () {
            // flag 控制全选按钮是否选中
            var flag = true;
            // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
            for (var i = 0; i < j_tbs.length; i++) {
              // 只要有没打钩的，if(true) 中的值就是 true；flag 就为 false
              if (!j_tbs[i].checked) {
                flag = false;
                break; // 退出for循环 这样可以提高执行效率 因为只要有一个没有选中，剩下的就无需循环判断了
              }
            }
            j_cbAll.checked = flag;
          };
        }
      </script>
    </body>
  </html>
  ```

## 4.6、自定义属性

### 4.6.1、获取属性值

- 获取**内置属性值** (元素**本身自带**的属性)
  - `element.属性;`
- 获取**自定义的属性**
  - `element.getAttribute('属性');`

### 4.6.2、设置属性值

- 设置**内置属性**值
  - `element.属性 = '值';`

- 主要设置**自定义的属性**
  - `element.setAttribute('属性', '值');`

### 4.6.3、移除属性

- `element.removeAttribute('属性');`

```html
<body>
    <div id="demo" index="1" class="nav"></div>
    <script>
        var div = document.querySelector('div');
        // 1. 获取元素的属性值
        // (1) element.属性
        console.log(div.id);
        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index 
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
        // 2. 设置元素属性值
        // (1) element.属性= '值'
        div.id = 'test';
        div.className = 'navs';
        // (2) element.setAttribute('属性', '值');  主要针对于自定义属性
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer'); // class 特殊，这里面写的就是class，不是className
        // 3 移除属性 removeAttribute(属性)    
        div.removeAttribute('index');
    </script>
</body>
```

### # tab栏切换 (重点)

- 点了那个 `tab`，其下方对应的 `div` 显示；其他 `div` 隐藏

- ![image-20211207160047693](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207160047693.png)

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          * {
              margin: 0;
              padding: 0;
          }
          
          li {
              list-style-type: none;
          }
          
          .tab {
              width: 978px;
              margin: 100px auto;
          }
          
          .tab_list {
              height: 39px;
              border: 1px solid #ccc;
              background-color: #f1f1f1;
          }
          
          .tab_list li {
              float: left;
              height: 39px;
              line-height: 39px;
              padding: 0 20px;
              text-align: center;
              cursor: pointer;
          }
          
          .tab_list .current {
              background-color: #c81623;
              color: #fff;
          }
          
          .item_info {
              padding: 20px 0 0 20px;
          }
          
          .item {
              display: none;
          }
      </style>
  </head>
  
  <body>
      <div class="tab">
          <div class="tab_list">
              <ul>
                  <li class="current">商品介绍</li>
                  <li>规格与包装</li>
                  <li>售后保障</li>
                  <li>商品评价（50000）</li>
                  <li>手机社区</li>
              </ul>
          </div>
          <div class="tab_con">
              <div class="item" style="display: block;">
                  商品介绍模块内容
              </div>
              <div class="item">
                  规格与包装模块内容
              </div>
              <div class="item">
                  售后保障模块内容
              </div>
              <div class="item">
                  商品评价（50000）模块内容
              </div>
              <div class="item">
                  手机社区模块内容
              </div>
  
          </div>
      </div>
      <script>
          // 获取元素
          // 父
          var tab_list = document.querySelector('.tab_list');
          // 子
          var lis = tab_list.querySelectorAll('li');
          var items = document.querySelectorAll('.item');
          // for循环绑定点击事件
          for (var i = 0; i < lis.length; i++) {
              // 开始给5个小li, 分别设置索引号 【index】
              lis[i].setAttribute('index', i);
              
              lis[i].onclick = function() {
                  // 1. 上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类名的方式
  
                  // 干掉所有人 其余的li清除 class 这个类
                  for (var i = 0; i < lis.length; i++) {
                      lis[i].className = '';
                  }
                  // 留下我自己 （变红）
                  this.className = 'current';
                  
                  // 2. 下面的显示内容模块
                  var index = this.getAttribute('index');
  
                  // 干掉所有人 让其余的item 这些div 隐藏
                  for (var i = 0; i < items.length; i++) {
                      items[i].style.display = 'none';
                  }
                  
                  // 留下我自己 让对应的item 显示出来
                  items[index].style.display = 'block';
              }
          }
      </script>
  </body>
  ```

- ![image-20211207160213757](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207160213757.png)



## 4.7、H5自定义属性

自定义属性目的：

- **保存并使用数据**，有些数据可以**保存到页面中**而不用保存到数据库中
- 有些自定义属性很容易引起歧义，不容易判断到底是内置属性还是自定义的，所以H5有了规定

### 4.7.1 设置H5自定义属性

- H5规定自定义属性 `data-`开头作为属性名并赋值

  - ```js
    <div data-index = "1"></>
    
    // 或者使用JavaScript设置
    div.setAttribute('data-index',1);
    ```

- ```html
  <body>
      <div getTime="20" data-index="2" data-list-name="andy"></div>
      <script>
          var div = document.querySelector('div');
          console.log(div.getAttribute('getTime'));
          
          div.setAttribute('data-time', 20);
          console.log(div.getAttribute('data-index'));
          console.log(div.getAttribute('data-list-name'));
      </script>
  </body>
  ```

  

### 4.7.2 获取H5自定义属性

- 兼容性获取 `element.getAttribute('data-index')`

- H5新增的：`element.dataset.index` 或 `element.dataset['index']` IE11才开始支持

  - 如果自定义属性里面有多个 `"-"` 链接的单词，我们获取的时候采取**驼峰命名法**
  - h5新增的获取自定义属性的方法, **它只能获取`data-`开头的**

- ```html
  <body>
      <div getTime="20" data-index="2" data-list-name="andy"></div>
      <script>
          var div = document.querySelector('div');
          // get
          console.log(div.getAttribute('getTime'));
          div.setAttribute('data-time', 20);
          console.log(div.getAttribute('data-index'));
          console.log(div.getAttribute('data-list-name'));
          
          // h5新增的获取自定义属性的方法 它只能获取data-开头的
          // dataset 是一个集合里面存放了所有以data开头的自定义属性
          console.log(div.dataset);
          console.log(div.dataset.index);
          console.log(div.dataset['index']);
          
          // 如果自定义属性里面有多个 "-" 链接的单词，我们获取的时候采取 驼峰命名法
          console.log(div.dataset.listName);
          console.log(div.dataset['listName']);
      </script>
  </body>
  ```

- ![image-20211207171417430](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211207171417430.png)

# 5、节点操作

- 获取元素通常使用两种方式：
  - ![image-20211208111921353](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208111921353.png)

## 5.1、节点概述

- 网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。

- HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。

- ![在这里插入图片描述](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/f176c025b5ff43468d53ed4d49259812.png)

- 一般的，节点至少拥有`nodeType`（节点类型）、`nodeName`（节点名称）和`nodeValue`（节点值）这三个基本属性。

  - **元素节点**：nodeType 为 **1**
  - **属性节点**：nodeType 为 **2**
  - **文本节点**：nodeType 为 **3** (文本节点包括文字、空格、换行等)

- 我们在实际开发中，节点操作主要操作的是 **元素节点**

- 利用 DOM 树可以把节点划分为不同的层级关系，常见的是 **父子兄层级关系**。

  - ```html
    <body>
        <!-- 节点的优点 -->
        <div>我是div</div>
        <span>我是span</span>
        <ul>
            <li>我是li</li>
            <li>我是li</li>
            <li>我是li</li>
            <li>我是li</li>
        </ul>
        <div class="box">
            <span class="erweima">×</span>
        </div>
        <script>
            var box = document.querySelector('.box');
            console.dir(box);
        </script>
    </body>
    ```

## 5.2、父级节点

- `parentNode`属性可以返回**某节点的父结点**，注意是**最近**的一个**父结点**

- 如果指定的节点**没有父结点**则返回 `null`

  - ```js
    <body>
        <!-- 节点的优点 -->
        <div>我是div</div>
        <span>我是span</span>
        <ul>
            <li>我是li</li>
            <li>我是li</li>
            <li>我是li</li>
            <li>我是li</li>
        </ul>
        <div class="demo">
            <div class="box">
                <span class="erweima">×</span>
            </div>
        </div>
    
        <script>
            // 1. 父节点 parentNode
            var erweima = document.querySelector('.erweima');
            // var box = document.querySelector('.box');
            // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
            console.log(erweima.parentNode);
        </script>
    </body>
    ```

## 5.3、子结点

```js
parentNode.childNodes  【标准】
```

- `parentNode.childNodes` 返回包含指定节点的子节点的集合，该集合为即时更新的集合
- 返回值**包含了所有的子结点**，包括**元素节点**，**文本节点**等
- 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用`childNodes`

```js
parentNode.children  【非标准】
```

- `parentNode.children` 是一个只读属性，返回**所有的子元素节点**
- 它只返回**子元素节点**，其余节点不返回 （**这个是我们重点掌握的**）
- 虽然 children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用

### 案例

- ```html
  <body>
      <!-- 节点的优点 -->
      <div>我是div</div>
      <span>我是span</span>
      <ul>
          <li>我是li</li>
          <li>我是li</li>
          <li>我是li</li>
          <li>我是li</li>
  
      </ul>
      <ol>
          <li>我是li</li>
          <li>我是li</li>
          <li>我是li</li>
          <li>我是li</li>
      </ol>
  
      <div class="demo">
          <div class="box">
              <span class="erweima">×</span>
          </div>
      </div>
  
      <script>
          // DOM 提供的方法（API）获取
          var ul = document.querySelector('ul');
          var lis = ul.querySelectorAll('li');
          
          // 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等
          console.log(ul.childNodes);
          console.log(ul.childNodes[0].nodeType);
          console.log(ul.childNodes[1].nodeType);
          // 2. children 获取所有的子元素节点 也是我们实际开发常用的
          console.log(ul.children);
      </script>
  </body>
  ```

- `nodeType` 判断元素节点类型

- ![image-20211208115441537](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208115441537.png)

### 5.3.1、第一个子结点

```js
parentNode.firstChild
```

- `lastChild` 返回最后一个子节点，找不到则返回`null`
- 同样，也是包含**所有的节点**：**包括文本节点**

### 5.3.2、最后一个子结点

```js
parentNode.lastChild
```

- `lastChild` 返回最后一个子节点，找不到则返回null
- 同样，也是**包含所有的节点**

### 5.3.3、第一个子结点(兼容性)

```js
parentNode.firstElementChild
```

- `firstElementChild` 返回第一个子节点，找不到则返回 `null`
- 有兼容性问题，IE9以上才支持

### 5.3.4、最后一个子结点(兼容性)

```js
parentNode.lastElementChild
```

- `lastElementChild` 返回最后一个子节点，找不到则返回 `null`
- 有兼容性问题，IE9以上才支持

### 5.3.5、解决方案

- 如果想要**第一个**子元素节点，可以使用：
  - `parentNode.chilren[0]`
- 如果想要**最后一个**子元素节点，可以使用：
  - `parentNode.chilren[parentNode.chilren.length - 1]`

### 案例

```html
<body>
    <ol>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
        <li>我是li5</li>
    </ol>
    <script>
        var ol = document.querySelector('ol');
        // 1. firstChild 第一个子节点，不管是文本节点还是元素节点
        console.log(ol.firstChild);
        console.log(ol.lastChild);

        // 2. firstElementChild 返回第一个子元素节点 ie9才支持
        console.log(ol.firstElementChild);
        console.log(ol.lastElementChild);

        // 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素
        console.log(ol.children[0]);
        console.log(ol.children[ol.children.length - 1]);
    </script>
</body>
```

### # 新浪下拉菜单

- ![image-20211208121540080](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208121540080.png)

- ```html
  <body>
      <ul class="nav">
          <li>
              <a href="#">微博</a>
              <ul>
                  <li>
                      <a href="">私信</a>
                  </li>
                  <li>
                      <a href="">评论</a>
                  </li>
                  <li>
                      <a href="">@我</a>
                  </li>
              </ul>
          </li>
          <li>
              <a href="#">微博</a>
              <ul>
                  <li>
                      <a href="">私信</a>
                  </li>
                  <li>
                      <a href="">评论</a>
                  </li>
                  <li>
                      <a href="">@我</a>
                  </li>
              </ul>
          </li>
          <li>
              <a href="#">微博</a>
              <ul>
                  <li>
                      <a href="">私信</a>
                  </li>
                  <li>
                      <a href="">评论</a>
                  </li>
                  <li>
                      <a href="">@我</a>
                  </li>
              </ul>
          </li>
          <li>
              <a href="#">微博</a>
              <ul>
                  <li>
                      <a href="">私信</a>
                  </li>
                  <li>
                      <a href="">评论</a>
                  </li>
                  <li>
                      <a href="">@我</a>
                  </li>
              </ul>
          </li>
      </ul>
      <script>
          // 1. 获取元素
          var nav = document.querySelector('.nav');
          var lis = nav.children; // 得到4个小li
          // 2.循环注册事件
          for (var i = 0; i < lis.length; i++) {
              lis[i].onmouseover = function() {
                  this.children[1].style.display = 'block';
              }
              lis[i].onmouseout = function() {
                  this.children[1].style.display = 'none';
              }
          }
      </script>
  </body>
  ```

- ![image-20211208122005771](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208122005771.png)



## 5.4、兄弟节点

### 5.4.1、下一个兄弟节点

```js
node.nextSibling
```

- `nextSibling` 返回当前元素的下一个兄弟元素节点，找不到则返回 `null`
- 同样，也是**包含所有的节点**

### 5.4.2、上一个兄弟节点

```js
node.previousSibling
```

- `previousSibling` 返回当前元素上一个兄弟元素节点，找不到则返回`null`
- 同样，也是包含所有的节点

### 5.4.3、下一个兄弟元素节点(兼容性)

```js
node.nextElementSibling
```

- `nextElementSibling` 返回当前元素下一个**兄弟元素节点**，找不到则返回`null`
- 有兼容性问题，IE9才支持

### 5.4.4、上一个兄弟元素节点(兼容性)

```js
node.previousElementSibling
```

- `previousElementSibling` 返回当前元素上一个**兄弟元素节点**，找不到则返回`null`
- 有兼容性问题，IE9才支持

## 5.5、创建节点

```js
document.createElement('tagName'); // li
```

- `document.createElement()` 方法创建由 `tagName` 指定的 HTML 元素
- 因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为**动态创建元素节点**

### 5.5.1、添加节点

```js
node.appendChild(child) // 向后添加
```

- `node.appendChild()` 方法将一个节点添加到**指定父节点的子节点**列表**末尾**。类似于 CSS 里面的 after 伪元素。
- `node`：父亲
- `child`：孩子

```js
node.insertBefore(child,指定元素) // 向前添加
```

- `node.insertBefore()` 方法将一个节点添加到父节点的指定子节点**前面**。类似于 CSS 里面的 before 伪元素。

```html
<body>
    <ul>
        <li>123</li>
    </ul>
    <script>
        // 1. 创建节点元素节点
        var li = document.createElement('li');
        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的push
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素);
        var lili = document.createElement('li');
        ul.insertBefore(lili, ul.children[0]);
        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
    </script>
</body>
```

- ![image-20211208134108674](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208134108674.png)



### # 简单版发布留言案例

- ```html
  <body>
      <textarea name="" id=""></textarea>
      <button>发布</button>
      <ul>
  
      </ul>
      <script>
          // 1. 获取元素
          var btn = document.querySelector('button');
          var text = document.querySelector('textarea');
          var ul = document.querySelector('ul');
          // 2. 注册事件
          btn.onclick = function() {
              if (text.value == '') {
                  alert('您没有输入内容');
                  return false;
              } else {
                  // console.log(text.value);
                  // (1) 创建元素
                  var li = document.createElement('li');
                  // 先有li 才能赋值
                  li.innerHTML = text.value;
                  // (2) 添加元素
                  // ul.appendChild(li);  // 在后方插入
                  ul.insertBefore(li, ul.children[0]);
              }
          }
      </script>
  </body>
  ```

### 5.5.2、删除节点

```js
node.removeChild(child)
```

- `node.removeChild()`方法从 DOM 中删除一个子节点，**返回删除的节点**

### 案例

- ```html
  <body>
      <button>删除</button>
      <ul>
          <li>熊大</li>
          <li>熊二</li>
          <li>光头强</li>
      </ul>
      <script>
          // 1.获取元素
          var ul = document.querySelector('ul');
          var btn = document.querySelector('button');
          // 2. 删除元素  node.removeChild(child)
          // ul.removeChild(ul.children[0]);
          // 3. 点击按钮依次删除里面的孩子
          btn.onclick = function() {
              if (ul.children.length == 0) {
                  this.disabled = true;
              } else {
                  ul.removeChild(ul.children[0]);
              }
          }
      </script>
  </body>
  ```

- ![image-20211208151324569](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208151324569.png)

### 5.5.3、复制节点(克隆节点)

```js
node.cloneNode()
```

- `node.cloneNode()`方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点

- 如果括号参数为**空**或者为 **false** ，则是**浅拷贝**，即只**克隆复制节点本身**，**不克隆里面的子节点**

- 如果括号参数为 **true** ，则是**深度拷贝**，会复制**节点本身以及里面所有的子节点**

- ```html
  <body>
      <ul>
          <li>1111</li>
          <li>2</li>
          <li>3</li>
      </ul>
      <script>
          var ul = document.querySelector('ul');
          // 1. node.cloneNode(); 括号为空或者里面是false, 浅拷贝, 只复制标签不复制里面的内容
          // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
          var lili = ul.children[0].cloneNode(true);
          ul.appendChild(lili);
      </script>
  </body>
  ```

- ![image-20211208151349788](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208151349788.png)

### # 删除留言案例

- ```html
  <body>
      <textarea name="" id=""></textarea>
      <button>发布</button>
      <ul>
  
      </ul>
      
      <script>
          // 1. 获取元素
          var btn = document.querySelector('button');
          var text = document.querySelector('textarea');
          var ul = document.querySelector('ul');
          // 2. 注册事件
          btn.onclick = function() {
              if (text.value == '') {
                  alert('您没有输入内容');
                  return false;
              } else {
                  // console.log(text.value);
                  // (1) 创建元素
                  var li = document.createElement('li');
                  
                  // 先有li 才能赋值
                  li.innerHTML = text.value + "<a href='javascript:;'>删除</a>";
                  
                  // (2) 添加元素
                  // ul.appendChild(li);
                  ul.insertBefore(li, ul.children[0]);
                  
                  // (3) 删除元素 删除的是当前链接的li,它的父亲
                  var as = document.querySelectorAll('a');
                  for (var i = 0; i < as.length; i++) {
                      as[i].onclick = function() {
                          // node.removeChild(child); 删除的是 li 当前a所在的li, this.parentNode;
                          ul.removeChild(this.parentNode);
                      }
                  }
              }
          }
      </script>
  </body>
  ```

### # 动态生成表格案例

- `tbody` -> `tr` -> `td`

- 在每行 `tr` 中增加 `td`（姓名、科目、成绩），然后再添加最后一列 `td`（操作）

- ```html
  <body>
      <table cellspacing="0">
          <thead>
              <tr>
                  <th>姓名</th>
                  <th>科目</th>
                  <th>成绩</th>
                  <th>操作</th>
              </tr>
          </thead>
          <tbody>
  
          </tbody>
      </table>
      <script>
          // 1.先去准备好学生的数据
          var datas = [{
              name: '魏璎珞',
              subject: 'JavaScript',
              score: 100
          }, {
              name: '弘历',
              subject: 'JavaScript',
              score: 98
          }, {
              name: '傅恒',
              subject: 'JavaScript',
              score: 99
          }, {
              name: '明玉',
              subject: 'JavaScript',
              score: 88
          }, {
              name: '大猪蹄子',
              subject: 'JavaScript',
              score: 0
          }];
          // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行
          var tbody = document.querySelector('tbody');
          for (var i = 0; i < datas.length; i++) { // 外面的for循环管行 tr
              
              // 1. 创建 tr行
              var tr = document.createElement('tr');
              tbody.appendChild(tr);
              
              // 2. 行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数  for循环遍历对象 datas[i]
              for (var k in datas[i]) { // 里面的for循环管列 td
                  // 创建单元格 
                  var td = document.createElement('td');
                  // 把对象里面的属性值 datas[i][k] 给 td  
                  // console.log(datas[i][k]);
                  td.innerHTML = datas[i][k];
                  tr.appendChild(td);
              }
              
              // 3. 创建有删除2个字的单元格 
              var td = document.createElement('td');
              td.innerHTML = '<a href="javascript:;">删除 </a>';
              tr.appendChild(td);
  
          }
          
          // 4. 删除操作 开始 
          var as = document.querySelectorAll('a');
          for (var i = 0; i < as.length; i++) {
              as[i].onclick = function() {
                  // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child) 
                  // 删除 tr （a -> td -> tr）
                  tbody.removeChild(this.parentNode.parentNode)
              }
          }
          
          // for(var k in obj) {
          //     k 得到的是属性名
          //     obj[k] 得到是属性值
          // }
      </script>
  </body>
  ```

- ![image-20211208161115458](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208161115458.png)

- ![image-20211208170158168](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211208170158168.png)



## 5.8 三种动态创建元素区别

三种动态创建元素的区别

- **`doucument.write()`**
  - `document.write()` 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致**页面全部重绘**
  - 只有新写入的元素，其他全部没有了
- **`element.innerHTML`**
  - `innerHTML` 是将内容写入某个 DOM 节点，**不会导致页面全部重绘**
- **`document.createElement()`**
  - `innerHTML` 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
- **innerHTML 效率要比 creatElement 高**

```html
<body>
    <button>点击</button>
    <p>abc</p>
    <div class="inner"></div>
    <div class="create"></div>
    <script>
        window.onload = function () {
            document.write("<div>123</div>");
        };

        // 三种创建元素方式区别
        // 1. document.write() 创建元素, 如果页面文档流加载完毕，再调用这句话会导致页面重绘
        var btn = document.querySelector("button");
        btn.onclick = function () {
            document.write("<div>123</div>");
        };

        // 2. innerHTML 创建元素
        var inner = document.querySelector(".inner");
        // 方法一
        for (var i = 0; i <= 100; i++) {
            inner.innerHTML += '<a href="#">百度</a>'
        }
        
        // 方法二
        var arr = [];
        for (var i = 0; i <= 100; i++) {
            arr.push('<a href="#">百度</a>');
        }
        inner.innerHTML = arr.join("");

        // 3. document.createElement() 创建元素
        var create = document.querySelector(".create");
        for (var i = 0; i <= 100; i++) {
            var a = document.createElement("a");
            create.appendChild(a);
        }
    </script>
</body>
```

# 6、DOM核心总结

对于DOM操作，我们主要针对子元素的操作，主要有

- 创建
- 增
- 删
- 改
- 查
- 属性操作
- 时间操作

## 6.1、创建

1. `document.write`
2. `innerHTML`
3. `createElement`

## 6.2、增

1. `appendChild`
2. `insertBefore`

## 6.3、删

1. `removeChild`

## 6.4、改

- 主要修改dom的元素属性，dom元素的内容、属性、表单的值等

1. 修改元素属性：`src`、`href`、`title` 等
2. 修改普通元素内容：`innerHTML`、`innerText`
3. 修改表单元素：`value`、`type`、`disabled`
4. 修改元素样式：`style`、`className`

## 6.5、查

- 主要获取查询`dom`的元素

1. **DOM提供的API方法**：`getElementById`、`getElementsByTagName` (古老用法，不推荐)
2. **H5提供的新方法**：`querySelector`、`querySelectorAll` (提倡)
3. 利用节点操作获取元素：父(`parentNode`)、子(`children`)、兄(`previousElementSibling`、`nextElementSibling`) 提倡

## 6.6、属性操作

- 主要针对于自定义属性

1. `setAttribute`：设置`dom`的属性值
2. `getAttribute`：得到`dom`的属性值
3. `removeAttribute`：移除属性

## 6.7 事件操作

- ![image-20211209133752322](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211209133752322.png)

# 7、事件高级

## 7.1、注册事件(绑定事件)

- 给元素添加事件，称为注册事件或者绑定事件
- 注册事件有两种方式：**传统方式**方式 和 **监听注册**方式
- ![image-20211209133930227](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211209133930227.png)

### ① `addEventListener`事件监听方式

- `eventTarget.addEventListener()`方法将指定的监听器注册到 `eventTarget`（目标对象）上
- 当该对象触发指定的事件时，就会执行事件处理函数

```js
eventTarget.addEventListener(type,listener[, useCapture])
```

该方法接收三个参数：

- `type`:事件类型字符串，比如`click`, `mouseover`,注意这里不要带 on
- `listener`：事件处理函数，事件发生时，会调用该监听函数
- `useCapture`：可选参数，是一个布尔值，默认是 `false`。学完 DOM 事件流后，我们再进一步学习



### ② `attachEvent`事件监听方式(兼容)

- `eventTarget.attachEvent()`方法将指定的监听器注册到 eventTarget（目标对象） 上
- 当该对象触发指定的事件时，指定的回调函数就会被执行

```js
eventTarget.attachEvent(eventNameWithOn, callback)
```

该方法接收两个参数：

- `eventNameWithOn`：事件类型字符串，比如 `onclick` 、`onmouseover` ，这里要带 on
- `callback`：事件处理函数，当目标触发事件时回调函数被调用
- ie9 以前的版本支持
- ![image-20211209144121601](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211209144121601.png)

### 案例

```html
<body>
    <button>传统注册事件</button>
    <button>方法监听注册事件</button>
    <button>ie9 attachEvent</button>
    <script>
        var btns = document.querySelectorAll("button");
        
        // 1. 传统方式注册事件
        btns[0].onclick = function () {
            alert("hi");
        };
        btns[0].onclick = function () {
            alert("hao a u");
        };
        
        // 2. 事件侦听注册事件 addEventListener
        // (1) 里面的事件类型是字符串 必定加引号 而且不带on
        // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）
        btns[1].addEventListener("click", function () {
            alert(22);
        });
        
        btns[1].addEventListener("click", function () {
            alert(33);
        });
        
        // 3. attachEvent ie9以前的版本支持
        btns[2].attachEvent("onclick", function () {
            alert(11);
        });
    </script>
</body>
```

1. 里面的事件类型是**字符串**, 必定**加引号**, 而且**不带on**
2. **同一个元素**, **同一个事件**可以添加**多个侦听器**（事件处理程序）

### ③ 注册事件兼容性解决方案

- 兼容性处理的原则：首先照顾大多数浏览器，再处理特殊浏览器

- ```js
  function addEventListener(element, eventName, fn) {
      // 判断当前浏览器是否支持 addEventListener 方法
      if (element.addEventListener) {
          element.addEventListener(eventName, fn);  // 第三个参数 默认是false
      } else if (element.attachEvent) {
          element.attachEvent('on' + eventName, fn);
      } else {
          // 相当于 element.onclick = fn;
          element['on' + eventName] = fn;
      } 
  }
  ```



## 7.2、删除事件(解绑事件)

### 7.2.1、`removeEventListener`删除事件方式

```js
eventTarget.removeEventListener(type,listener[,useCapture]);
```

该方法接收三个参数：

- `type`:事件类型字符串，比如click,mouseover,注意这里不要带on
- `listener`：事件处理函数，事件发生时，会调用该监听函数
- `useCapture`：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习

```html
<body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        
        // 2. removeEventListener 删除事件
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号

        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        
        // 3. detachEvent
        divs[2].attachEvent('onclick', fn1);

        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
    </script>
</body>
```

- 如果需要删除，**不能使用匿名函数**，必须声明函数 `function fn(){}`
- ![image-20211210113453347](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211210113453347.png)

### 7.2.2、detachEvent删除事件方式(兼容)

```js
eventTarget.detachEvent(eventNameWithOn,callback);
```

该方法接收两个参数：

- `eventNameWithOn`：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on
- `callback`： 事件处理函数，当目标触发事件时回调函数被调用
- ie9以前的版本支持

### 7.2.3、传统事件删除方式

```js
eventTarget.onclick = null;
```

### 案例

```html
<body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        // 2.removeEventListener 删除事件
        divs[1].addEventListener('click',fn);   //里面的fn不需要调用加小括号

        function fn(){
            alert(22);
            divs[1].removeEventListener('click',fn);
        }
        // 3.IE9 中的删除事件方式
        divs[2].attachEvent('onclick',fn1);
        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick',fn1);
        }
    </script>
</body>
```

### 7.2.4、删除事件兼容性解决方案

```js
function removeEventListener(element, eventName, fn) {
    // 判断当前浏览器是否支持 removeEventListener 方法
    if (element.removeEventListener) {
        element.removeEventListener(eventName, fn);  // 第三个参数 默认是false
    } else if (element.detachEvent) {
        element.detachEvent('on' + eventName, fn);
    } else {
        element['on' + eventName] = null;
    } 
}
```

## 7.3、DOM事件流

- 事件流描述的是**从页面中接收事件的顺序**
- 事件发生时会**在元素节点之间按照特定的顺序传播**，这个传播过程即 DOM 事件流
- ![在这里插入图片描述](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/063297f2336f43dfb246930ae877a9ad.png)
  - **事件冒泡**： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。
  - **事件捕获**： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。
- ![在这里插入图片描述](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/51f0146f0e334813b35d9b7075382a33.png)

### 注意：

1. JS 代码中只能执行 **捕获** 或者 **冒泡** 其中一个阶段
2. `onclick` 和 `attachEvent` 只能得到**冒泡阶段**

### 案例

- `element.addEventListener("click", function(){}, true)`
  - `true` ：处于**捕获**阶段
    - **document -> html -> body -> father -> son**
      - 先执行 `father`，再执行 `son` （捕获阶段）
  - `false` ：处于**冒泡**阶段
    - **document <- html <- body <- father <- son**
      - 先执行 `son`，再执行 `father` （都是冒泡阶段）

- ```html
  <body>
      <div class="father">
          <div class="son">son盒子</div>
      </div>
      <script>
          // dom 事件流 三个阶段
          // 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。
          // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。
          // 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段  document -> html -> body -> father -> son
          var son = document.querySelector(".son");
          son.addEventListener(
              "click",
              function () {
                  alert("son");
              },
              true
          );
  
  
          var father = document.querySelector(".father");
          father.addEventListener(
              "click",
              function () {
                  alert("father");
              },
              true
          );
  
          // 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  son -> father ->body -> html -> document
          var son = document.querySelector(".son");
          son.addEventListener(
              "click",
              function () {
                  alert("son");
              },
              false
          );
          var father = document.querySelector(".father");
          father.addEventListener(
              "click",
              function () {
                  alert("father");
              },
              false
          );
          document.addEventListener("click", function () {
              alert("document");
          });
      </script>
  </body>
  ```

- **捕获**阶段:![在这里插入图片描述](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/65d6a7c8038f414fbf03c3ac4d2ce293.gif)

- **冒泡**阶段![在这里插入图片描述](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/9ab4190f50d14c7aa879789476a394e9.gif)

### 7.3.3、小结

- JS 代码中只能执行 `捕获` 或者 `冒泡` 其中的一个阶段
- `onclick` 和 `attachEvent`只能得到**冒泡**阶段
- `addEventListener(type,listener[,useCapture])`第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false),表示在事件冒泡阶段调用事件处理程序
- 实际开发中我们很少使用事件捕获，我们**更关注事件冒泡**。
- 有些事件是没有冒泡的，比如 `onblur`、`onfocus`、`onmouseenter`、`onmouseleave`

## 7.4、事件对象

- ```js
  eventTarget.onclick = function(event) {
     // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
  } 
  eventTarget.addEventListener('click', function(event) {
     // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  
  })
  ```

- 官方解释：`event` 对象代表事件的状态，比如**键盘按键**的状态、**鼠标的位置**、**鼠标按钮的状态**

- 这个对象就是事件对象 event，它有很多属性和方法，比如

  - 谁绑定了这个事件
  - 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置
  - 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键

- 这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去

- 当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）

- ```html
  <body>
      <div>123</div>
      <script>
          // 事件对象: 普通方法
          var div = document.querySelector("div");
          div.onclick = function (e) {
              console.log(e);
              // ie 60708
              console.log(window.event);
              e = e || window.event;
              console.log(e);
          };
          
          // addEventListener
          div.addEventListener("click", function (e) {
              console.log(e);
          });
  
      </script>
  </body>
  ```

  1. event 就是一个事件对象 写到我们侦听函数的，小括号里面，当形参来看
  2. 事件对象**只有有了事件才会存在**，它是**系统**给我们**自动创建**的，不需要我们传递参数
  3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的，比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键
  4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e
  5. 事件对象也有兼容性问题 ie678 通过 `window.event` 兼容性的写法  `e = e || window.event;`

- ![image-20211211154125404](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211211154125404.png)

### 7.4.2、事件对象的常见属性和方法

- ![image-20211211154209990](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211211154209990.png)

- `e.target` 和 `this` 的区别：

  - `this` 是**事件绑定的元素**， 这个函数的调用者（绑定这个事件的元素）
  - `e.target` 是**事件触发的元素**

- ```html
  <body>
      <div>123</div>
      <ul>
          <li>abc</li>
          <li>abc</li>
          <li>abc</li>
      </ul>
      <script>
          // 常见事件对象的属性和方法
          // 1. e.target 返回的是触发事件的对象（元素）  this 返回的是绑定事件的对象（元素）
          // 区别 ： e.target 点击了那个元素，就返回那个元素; this 那个元素绑定了这个点击事件，那么就返回谁
          var div = document.querySelector("div");
          div.addEventListener("click", function (e) {
              console.log(e.target);
              console.log(this);
          });
          
          // ========================================================	
          var ul = document.querySelector("ul");
          ul.addEventListener("click", function (e) {
              // 我们给ul 绑定了事件  那么this 就指向ul
              console.log(this);
              console.log(e.currentTarget);
  
              // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li
              console.log(e.target);
          });
          
          // ========================================================	
          // 兼容性处理
          div.onclick = function (e) {
              e = e || window.event;
              var target = e.target || e.srcElement;
              console.log(target);
          };
          // 2. 了解 跟 this 有个非常相似的属性 currentTarget  ie678不认识
      </script>
  </body>
  ```

## 7.5、事件对象阻止默认行为

- 普通浏览器：`e.preventDefault()` 方法

- 低版本浏览器：`e.returnValue;` 属性

- 直接 `return false`，也可以阻止默认行为

- ```html
  <body>
      <div>123</div>
      <a href="http://www.baidu.com">百度</a>
      <form action="http://www.baidu.com">
          <input type="submit" value="提交" name="sub">
      </form>
      <script>
          // 常见事件对象的属性和方法
          // 1. 返回事件类型
          var div = document.querySelector('div');
          div.addEventListener('click', fn);
          div.addEventListener('mouseover', fn);
          div.addEventListener('mouseout', fn);
  
          function fn(e) {
              console.log(e.type);
  
          }
          
          // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交
          var a = document.querySelector('a');
          a.addEventListener('click', function(e) {
              e.preventDefault(); //  dom 标准写法
          })
          
          // 3. 传统的注册方式
          a.onclick = function(e) {
              // 普通浏览器 e.preventDefault();  方法
              e.preventDefault();
              
              // 低版本浏览器 ie678  returnValue  属性
              e.returnValue;
              
              // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式
              return false;
              alert(11);
          }
      </script>
  </body>
  
  ```



## 7.6、阻止事件冒泡

- **事件冒泡**：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点

- 事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

- 标准写法：`e.stopPropagation();`

- 非标准写法： IE6-8 利用对象事件 cancelBubble属性：`e.cancelBubble = true;`

- ```html
  <body>
      <div class="father">
          <div class="son">son儿子</div>
      </div>
  
      <script>
          // 常见事件对象的属性和方法
          // 阻止冒泡  dom 推荐的标准 stopPropagation() 
          
          // son
          var son = document.querySelector('.son');
          son.addEventListener('click', function(e) {
              alert('son');
              e.stopPropagation(); // stop 停止  Propagation 传播
              e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡
          }, false);
  
          // father
          var father = document.querySelector('.father');
          father.addEventListener('click', function() {
              alert('father');
          }, false);
  
          // document
          document.addEventListener('click', function() {
              alert('document');
          })
      </script>
  </body>
  ```

### 7.6.1、阻止事件冒泡的兼容性解决方案

- ```html
  <script>
      if(e && e.stopPropagation){
          e.stopPropagation();
      }else{
          window.event.cancelBubble = true;
      }
  </script>
  ```

## 7.7、事件委托

- 事件委托也称为事件代理，在 `jQuery` 里面称为事件委派

- 事件委托的原理

  - **不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点**

- ```html
  <body>
      <ul>
          <li>知否知否，点我应有弹框在手！</li>
          <li>知否知否，点我应有弹框在手！</li>
          <li>知否知否，点我应有弹框在手！</li>
          <li>知否知否，点我应有弹框在手！</li>
          <li>知否知否，点我应有弹框在手！</li>
      </ul>
      <script>
          // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
          var ul = document.querySelector('ul');
          ul.addEventListener('click', function(e) {
              // alert('知否知否，点我应有弹框在手！');
              
              // e.target 这个可以得到我们点击的对象
              e.target.style.backgroundColor = 'pink';
              // 点了谁，就让谁的style里面的backgroundColor颜色变为pink
          })
      </script>
  </body>
  ```

  - 点击 `li`，但是 `li` 有事件冒泡，冒泡给 `ul`，就有 `alert` 的提示
  - `e.target` 这个可以得到我们点击的对象
  - ![image-20211212215124129](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211212215124129.png)

## 7.8、常见的鼠标事件

- ![image-20211212215206024](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211212215206024.png)

### 7.8.1、禁止鼠标右键与鼠标选中

- `contextmenu`主要控制应该何时显示**上下文菜单**，主要用于程序员**取消默认的上下文菜单**

- `selectstart` 禁止鼠标选中

- ```html
  <body>
      <h1>我是一段不愿意分享的文字</h1>
      <script>
          // 1. contextmenu 我们可以禁用右键菜单
          document.addEventListener('contextmenu', function(e) {
              e.preventDefault(); // 阻止默认行为
          })
          
          // 2. 禁止选中文字 selectstart
          document.addEventListener('selectstart', function(e) {
              e.preventDefault();
          })
      </script>
  </body>
  ```

### 7.8.2、鼠标事件对象

- **event **对象代表事件的状态，跟事件相关的一系列信息的集合

- 现阶段我们主要是用鼠标事件对象 **MouseEvent** 和键盘事件对象 **KeyboardEvent。**

- ![image-20211212215824218](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211212215824218.png)

- ```html
  <body>
      <script>
          // 鼠标事件对象 MouseEvent
          document.addEventListener('click', function(e) {
              // 1. client 鼠标在可视区的x和y坐标
              console.log(e.clientX);
              console.log(e.clientY);
              console.log('---------------------');
  
              // 2. page 鼠标在页面文档的x和y坐标
              console.log(e.pageX);
              console.log(e.pageY);
              console.log('---------------------');
  
              // 3. screen 鼠标在电脑屏幕的x和y坐标
              console.log(e.screenX);
              console.log(e.screenY);
  
          })
      </script>
  </body>
  ```

  - 文档可能非常的长， `pageY` 就是距离文档最顶端的距离

### # 跟随鼠标的天使

- 鼠标移动，使用移动鼠标事件：mousemove

- 在页面中移动，给 document 注册时间

- 绝对定位

- 原理：每次移动鼠标，我们可以获得鼠标坐标，该 `x`，`y`作为图片的 `top` 和 `left` 值

- ```html
  <body>
      <img src="images/angel.gif" alt="" />
      
      <script>
          var pic = document.querySelector("img");
          document.addEventListener("mousemove", function (e) {
              // 1. mousemove只要我们鼠标移动1px 就会触发这个事件
              console.log(1);
              
              // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片
              var x = e.pageX;
              var y = e.pageY;
              console.log("x坐标是" + x, "y坐标是" + y);
              
              //3 . 千万不要忘记给left 和top 添加px 单位
              pic.style.left = x - 50 + "px";
              pic.style.top = y - 40 + "px";
          });
      </script>
  </body>
  ```




## 7.9、常用的键盘事件

- ![image-20211212223448762](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211212223448762.png)

- **如果使用 addEventListener 不需要加 on**

- `onkeypress` 和前面 2 个的区别是，它**不识别功能键**，比如 **左右箭头**，**shift** 等

- 三个事件的执行顺序是： **keydown –> keypress —> keyup**

- ```html
  <body>
      <script>
          // 常用的键盘事件
          //1. keyup 按键弹起的时候触发 
          document.onkeyup = function() {
              console.log('我弹起了');
          }
          
          document.addEventListener('keyup', function() {
              console.log('我弹起了');
          })
  		
          //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊
          document.addEventListener('keydown', function() {
              console.log('我按下了down');
          })
  		
          //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊
          document.addEventListener('keypress', function() {
              console.log('我按下了press');
          })
  
          // 4. 三个事件的执行顺序  keydown -- keypress -- keyup
      </script>
  </body>
  
  ```


### 7.9.1、键盘对象属性

- ![image-20211213133859121](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211213133859121.png)

- `onkeydown`和 `onkeyup` 不区分字母大小写，`onkeypress` 区分字母大小写。

- 在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键）

- `Keypress` 不识别功能键，但是`keyCode`属性能区分大小写，返回不同的ASCII值

- ```html
  <body>
      <script>
          // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值
          // 1. 我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65
          // 2. 我们的keypress 事件 区分字母大小写  a  97 和 A 得到的是65
          document.addEventListener('keyup', function(e) {
              console.log('up:' + e.keyCode);
              // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键
              if (e.keyCode === 65) {
                  alert('您按下的a键');
              } else {
                  alert('您没有按下a键')
              }
  
          })
          document.addEventListener('keypress', function(e) {
              console.log('press:' + e.keyCode);
          })
      </script>
  </body>
  ```

### # 模拟京东按键输入内容

- ```html
  <body>
      <input type="text">
      <script>
          // 核心思路： 检测用户是否按下了s 键，如果按下s 键，就把光标定位到搜索框里面
          // 使用键盘事件对象里面的keyCode 判断用户按下的是否是s键
          // 搜索框获得焦点： 使用 js 里面的 focus() 方法
          var search = document.querySelector('input');
          document.addEventListener('keyup', function(e) {
              // console.log(e.keyCode);
              if (e.keyCode === 83) {
                  search.focus();
              }
          })
      </script>
  </body>
  ```

  - 按下 s 自动进入搜索框
  - ![image-20211213144241146](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211213144241146.png)



### # 模拟京东快递单号查询案例

- 不能使用 `keydown` 和 `keypress`，因为时间触发时，文字还没有落入文本框

  - `keypress`：使用退格键时，都无法触发程序，导致上方 `div` 无改变

- ```html
  <!DOCTYPE html>
  <html lang="en">
  
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta http-equiv="X-UA-Compatible" content="ie=edge">
          <title>Document</title>
          <style>
              * {
                  margin: 0;
                  padding: 0;
              }
  
              .search {
                  position: relative;
                  width: 178px;
                  margin: 100px;
              }
  
              .con {
                  display: none;
                  position: absolute;
                  top: -40px;
                  width: 171px;
                  border: 1px solid rgba(0, 0, 0, .2);
                  box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
                  padding: 5px 0;
                  font-size: 18px;
                  line-height: 20px;
                  color: #333;
              }
  
              .con::before {
                  content: '';
                  width: 0;
                  height: 0;
                  position: absolute;
                  top: 28px;
                  left: 18px;
                  border: 8px solid #000;
                  border-style: solid dashed dashed;
                  border-color: #fff transparent transparent;
              }
          </style>
      </head>
  
      <body>
          <div class="search">
              <div class="con">123</div>
              <input type="text" placeholder="请输入您的快递单号" class="jd">
          </div>
          <script>
              // 快递单号输入内容时， 上面的大号字体盒子（con）显示(这里面的字号更大）
              // 表单检测用户输入： 给表单添加键盘事件
              // 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容
              // 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子
              var con = document.querySelector('.con');
              var jd_input = document.querySelector('.jd');
              jd_input.addEventListener('keyup', function() {
                  // console.log('输入内容啦');
                  if (this.value == '') {
                      con.style.display = 'none';
                  } else {
                      con.style.display = 'block';
                      con.innerText = this.value;
                  }
              })
              
              // 当我们失去焦点，就隐藏这个con盒子
              jd_input.addEventListener('blur', function() {
                  con.style.display = 'none';
              })
              
              // 当我们获得焦点，就显示这个con盒子
              jd_input.addEventListener('focus', function() {
                  if (this.value !== '') {
                      con.style.display = 'block';
                  }
              })
          </script>
      </body>
  </html>
  ```

- ![image-20211213144942631](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211213144942631.png)





























































