# 02.函数与作用域

# 1 函数

## 1.1 函数的使用

- 函数在使用时分为两步：**声明函数**和**调用函数**

### ①声明函数

- ```js
  //声明函数
  function 函数名(){
       //函数体代码
  }
  ```

- `function` 是声明函数的关键字,**必须小写**

- 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 `getSum`

### ②调用函数

- ```js
  //调用函数
  函数名(); //通过调用函数名来执行函数体代码
  ```

- 调用的时候**千万不要忘记添加小括号**

- 口诀：函数不调用，自己不执行

- **注意**：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码

## 1.2、函数的封装

- 函数的封装是把一个或者多个功能通过 **函数的方式** 封装起来，对外只提供一个简单的函数接口

## 1.3、函数的参数

- **在声明函数时**，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在**调用该函数**时，同样也需要传递相应的参数，这些参数被称为**实参**。

- ![image-20211128161240893](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211128161240893.png)

- **参数的作用** : 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递不同的值**进去

  - ```js
    // 带参数的函数声明
    function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
      // 函数体
    }
    
    
    // 带参数的函数调用
    函数名(实参1, 实参2, 实参3...); 
    ```

- 函数调用的时候实参值是传递给形参的

- 形参简单理解为:**不用声明的变量**

- 实参和形参的多个参数之间用 `逗号(,)` 分隔

### 1.3.2、形参和实参个数不匹配

- ![image-20211128161751131](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211128161751131.png)

- ```js
  function sum(num1, num2) {
      console.log(num1 + num2);
  }
  sum(100, 200);             // 300，形参和实参个数相等，输出正确结果
  
  sum(100, 400, 500, 700);   // 500，实参个数多于形参，只取到形参的个数
  
  sum(200);                  // 实参个数少于形参，多的形参定义为undefined，结果为NaN
  ```

- **注意：在JavaScript中，形参的默认值是undefined**

## 1.4、函数的返回值

### 1.4.1、return语句

- 有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

  - ```js
    // 声明函数
    function 函数名（）{
        ...
        return  需要返回的值;
    }
    // 调用函数
    函数名();    // 此时调用函数就可以得到函数体内return 后面的值
    ```

- 在使用 return 语句时，函数会停止执行，并返回指定的值

- 如果函数没有 return ，返回的值是 undefined

## 1.5 arguments的使用

- 当我们不确定有多少个参数传递的时候，可以用 `arguments` 来获取。在 JavaScript 中，`arguments` 实际上它是**当前函数的一个内置对象**

- 所有函数都内置了一个 `arguments` 对象，`arguments` 对象中存储了传递的所有实参

  - **arguments**存放的是传递过来的实参
  - **arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点**
    - ①：具有 length 属性
    - ②：按索引方式储存数据
    - ③：不具有数组的 push , pop 等方法

- ```js
  // 函数声明
  function fn() {
      console.log(arguments);  //里面存储了所有传递过来的实参
      console.log(arrguments.length); // 3
      console.log(arrguments[2]); // 3
  }
  
  // 函数调用
  fn(1,2,3);
  ```

- ```js
  // 例如：利用函数求任意个数的最大值 
  function maxValue() {
      var max = arguments[0];
      for (var i = 0; i < arguments.length; i++) {
          if (max < arguments[i]) {
              max = arguments[i];
          }
      }
      return max;
  }
  console.log(maxValue(2, 4, 5, 9)); // 9
  console.log(maxValue(12, 4, 9)); // 12
  ```

### 🔥 函数调用另外一个函数

- 因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。具体演示在下面的函数练习中会有

## 1.7 函数的两种声明方式

### 1.7.1、自定义函数方式(命名函数)

- 利用函数关键字 `function` 自定义函数方式

- ```js
  // 声明定义方式
  function fn() {...}
  
  // 调用  
  fn();
  ```

- **因为有名字，所以也被称为命名函数**

- **调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面**

### 1.7.2 函数表达式方式(匿名函数)

- ```js
  // 这是函数表达式写法，匿名函数后面跟分号结束
  var fn = function(){...};
  
  // 调用的方式，函数调用必须写到函数体下面
  fn();
  ```

- 因为函数没有名字，所以也称为**匿名函数**

- 这个fn 里面存储的是一个函数

- **函数调用的代码必须写到函数体后面**

# 2 作用域

JavaScript (ES6前) 中的作用域有两种：

- 全局作用域
- 局部作用域(函数作用域)

### 2.1 全局作用域🔥

- 作用于**所有代码**执行的环境(整个 script 标签内部)或者一个独立的 js 文件

### 2.2 局部（函数）作用域🔥

- **作用于函数内**的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域

### 2.3 JS 没有块级作用域🔥

- 块作用域由 {} 包括

- 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用

  - ```js
    if(true){
        int num = 123;
        System.out.println(num);	// 123
    }
    System.out.println(num);		// 报错
    ```

- JS 中没有块级作用域(在ES6之前)

  - ```js
    if(true){
        int num = 123;
        System.out.println(num);	// 123
    }
    System.out.println(num);		// 123
    ```

# 3 变量的作用域

在JavaScript中，根据作用域的不同，变量可以分为两种：

- 全局变量
- 局部变量

## 3.1 全局变量

在全局作用域下声明的变量叫做全局变量（**在函数外部定义的变量**）

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下 `var` 声明的变量 是**全局变量**
- 特殊情况下，在函数内不使用 `var` 声明的变量也是全局变量（不建议使用）

## 3.2 局部变量

在局部作用域下声明的变量叫做局部变量（**在函数内部定义的变量**）

- 局部变量只能在该函数内部使用
- 在函数内部 var 声明的变量是局部变量
- 函数的**形参**实际上就是**局部变量**

## 3.3 区别

- 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间

# 4 作用域链

1. 只要是代码，就至少有一个作用域

2. 写在**函数内部**的叫**局部作用域**

3. 如果**函数中还有函数**，那么在这个作用域中就又可以**诞生一个作用域**

4. 根据在**内部函数可以访问外部函数变量**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

5. ```js
   // 作用域链: 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链表
   
   var num = 10;
   funtion fn() { //外部函数
       var num = 20;
       
       function fun() { //内部函数
           console.log(num);  // 20 ,一级一级访问
       }
   }
   ```

6. 作用域链：采取 **就近原则** 的方式来查变量最终的值。

# 5 预解析

例子

- ```js
  // 命名函数(自定义函数方式):若我们把函数调用放在函数声明上面
  fn();				//11
  function fn() {
      console.log('11');
  }
  ```

  - 因为 函数提升，所有函数全部移动到最上方

- ```js
  // 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面
  fn();
  var  fn = function() {
      console.log('22'); // 报错
  }
  
  
  //相当于执行了以下代码
  var fn;
  fn();      //fn没赋值，没这个，报错
  var  fn = function() {
      console.log('22'); //报错
  }
  ```

`JavaScript` 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。

- **预解析**：js 引擎会把`js`里面所有的 `var` 还有 `function` 提升到当前作用域的最前面
- **代码执行**：从上到下执行JS语句

预解析只会发生在通过 var 定义的变量和 function 上。学习预解析能够让我们知道**为什么在变量声明之前访问变量的值是 undefined**，**为什么在函数声明之前就可以调用函数。**

## 5.1、变量预解析(变量提升)

- 变量预解析也叫做变量提升、函数提升

- 变量提升: 变量的声明会被提升到**当前作用域**的最上面，**变量的赋值不会提升**

- ```js
  console.log(num);  // 结果是多少？
  var num = 10;   
  // undefined
  
  
  //相当于执行了以下代码
  var num;		// 变量声明提升到当前作用域最上面
  console.log(num);
  num = 10;		// 变量的赋值不会提升
  ```

## 5.2、函数预解析(函数提升)

- 函数提升： 函数的声明会被提升到 **当前作用域** 的最上面，但是不会调用函数

- ```js
  fn();				//11
   
  function fn() {
      console.log('11');
  }
  ```

## 5.3、解决函数表达式声明调用问题

- 对于**函数表达式**声明调用需要记住：**函数表达式调用必须写在函数声明的下面**

- ```js
  // 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面
  fn();
  var  fn = function() {
      console.log('22'); // 报错
  }
  
  
  //相当于执行了以下代码
  var fn;
  fn();      //fn没赋值，没这个，报错
  fn = function() { // 把 函数 赋值到 fn
      console.log('22'); //报错
  }
  ```

### 预解析练习

- ```js
  // 练习1
  var num = 10;
  fun();
  function fun() {
      console.log(num);	//undefined
      var num = 20;
  }
  // 最终结果是 undefined
  
  -------------------------------------------------
  // 上述代码相当于执行了以下操作
  var num;
  function fun() {
      var num;
      console.log(num);
      num = 20;
  }
  num = 10;
  fun();
  ```

- ```js
  // 练习2
  var num = 10;
  function fn(){
      console.log(num);		//undefined
      var num = 20;
      console.log(num);		//20
  }
  fn();
  // 最终结果是 undefined 20
  
  -------------------------------------------------
  // 上述代码相当于执行了以下操作
  var num;
  function fn(){
      var num;
      console.log(num);
      num = 20;
      console.log(num);
  }
  ```

- ```js
  // 练习3
  var a = 18;
  f1();
  
  function f1() {
      var b = 9;
      console.log(a);
      console.log(b);
      var a = '123';
  }
  
  -------------------------------------------------
  // 上述代码相当于执行了以下操作
  var a;
  function f1() {
      var b;
      var a
      b = 9;
      console.log(a);	//undefined
      console.log(b);	//9
      a = '123';
  }
  a = 18;
  f1();
  ```

- ```js
  // 练习4
  f1();
  console.log(c);
  console.log(b);
  console.log(a);
  function f1() {
      var a = b = c = 9;
      // 相当于 var a = 9; b = 9;c = 9;  b和c的前面没有var声明,当全局变量看
      // 集体声明 var a = 9,b = 9,c = 9;
      console.log(a);
      console.log(b);
      console.log(c);
  }
  
  -------------------------------------------------
  // 上述代码相当于执行了以下操作
  function f1() {
      var a;
      a = b = c = 9;
      console.log(a);	//9
      console.log(b);	//9
      console.log(c);	//9
  }
  f1();
  console.log(c);	//9
  console.log(b);	//9
  console.log(a);	//报错 a是局部变量
  ```

- 

























