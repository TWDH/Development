

# 1. 元素偏移量 offset 系列

## 1.1 offset 概述

`offset` 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到`该元素的位置（偏移）`、`大小`等。

- 获得 **元素距离** 带有 **定位父元素** 的位置
- 获得元素**自身的大小**（宽度高度）
- 注意： 返回的数值都**不带单位**

offset 系列常用属性：

- ![image-20220108231301552](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220108231301552.png)

- ![image-20220109163100042](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109163100042.png)

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          * {
              margin: 0;
              padding: 0;
          }
          
          .father {
              /* position: relative; */
              width: 200px;
              height: 200px;
              background-color: pink;
              margin: 150px;
          }
          
          .son {
              width: 100px;
              height: 100px;
              background-color: purple;
              margin-left: 45px;
          }
          
          .w {
              height: 200px;
              background-color: skyblue;
              margin: 0 auto 200px;
              padding: 10px;
              border: 15px solid red;
          }
      </style>
  </head>
  
  <body>
      <div class="father">
          <div class="son"></div>
      </div>
      <div class="w"></div>
      
      <script>
          // offset 系列
          var father = document.querySelector('.father');
          var son = document.querySelector('.son');
          
          // 1.可以得到元素的偏移 位置 返回的不带单位的数值  
          console.log(father.offsetTop);
          console.log(father.offsetLeft);
          
          // 它以带有定位的父亲为准（150px），如果么有父亲或者父亲没有定位，则以 body 自身为准（195px）
          console.log(son.offsetLeft);
          
          // 获取 w 元素
          var w = document.querySelector('.w');
          
          // 2.可以得到元素的大小，宽度和高度，是包含 padding + border + width 
          console.log(w.offsetWidth);
          console.log(w.offsetHeight);
          
          // 3. 返回带有定位的父亲 否则返回的是body
          console.log(son.offsetParent); // 返回带有【定位】的父亲, 否则返回的是body
          console.log(son.parentNode); // 返回父亲, 是最近一级的父亲, 亲爸爸; 不管父亲有没有定位
      </script>
  </body>
  ```

- ![image-20220108233739665](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220108233739665.png)

## 1.2 offset 与 style 区别

- ![image-20220109162334050](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109162334050.png)
- offset 只读属性，不可改变
- style 可读写，可赋值

### # 案例：获取鼠标在盒子内的坐标

① 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。
② 首先得到鼠标在页面中的坐标（`e.pageX`, `e.pageY`）
③ 其次得到盒子在页面中的距离 ( `box.offsetLeft`, `box.offsetTop`)
④ 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标
⑤ 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件 mousemove

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          .box {
              width: 300px;
              height: 300px;
              background-color: pink;
              margin: 200px;
          }
      </style>
  </head>
  
  <body>
      <div class="box"></div>
      <script>
          // 我们在盒子内点击， 想要得到鼠标距离盒子左右的距离。
          // 首先得到鼠标在页面中的坐标（ e.pageX, e.pageY）
          // 其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)
          // 用鼠标距离页面的坐标减去盒子在页面中的距离， 得到 鼠标在盒子内的坐标
          var box = document.querySelector('.box');
          box.addEventListener('mousemove', function(e) {
              // console.log(e.pageX);
              // console.log(e.pageY);
              // console.log(box.offsetLeft);
              var x = e.pageX - this.offsetLeft;
              var y = e.pageY - this.offsetTop;
              this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
          })
      </script>
  </body>
  ```

- 

- ![image-20220109163242040](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109163242040.png)



### # 案例：模态框拖拽

弹出框，我们也称为模态框。
1. 点击弹出层， 会弹出模态框， 并且显示灰色半透明的遮挡层。
2. 点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。
3. 鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。
4. 鼠标松开，可以停止拖动模态框移动。

案例分析

- ① 点击弹出层， 模态框和遮挡层就会显示出来 display:block;
- ② 点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;
- ③ 在页面中拖拽的原理： 鼠标按下并且移动， 之后松开鼠标
- ④ 触发事件是鼠标按下 `mousedown`， 鼠标移动`mousemove` 鼠标松开 `mouseup`
- ⑤ 拖拽过程: 鼠标移动过程中，获得最新的值赋值给模态框的left和top值， 这样模态框可以跟着鼠标走了
- ⑥ 鼠标按下触发的事件源是 最上面一行，就是 id 为 title
- ⑦ 鼠标的坐标 减去 鼠标在盒子内的坐标， 才是模态框真正的位置。
- ⑧ 鼠标按下，我们要得到鼠标在盒子的坐标。
- ⑨ 鼠标移动，就让模态框的坐标 设置为 ： 鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。
- ⑩ 鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除

- ```html
  <head lang="en">
      <meta charset="UTF-8">
      <title></title>
      <style>
          .login-header {
              width: 100%;
              text-align: center;
              height: 30px;
              font-size: 24px;
              line-height: 30px;
          }
  
          ul,
          li,
          ol,
          dl,
          dt,
          dd,
          div,
          p,
          span,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          a {
              padding: 0px;
              margin: 0px;
          }
  
          .login {
              display: none;
              width: 512px;
              height: 280px;
              position: fixed;
              border: #ebebeb solid 1px;
              left: 50%;
              top: 50%;
              background: #ffffff;
              box-shadow: 0px 0px 20px #ddd;
              z-index: 9999;
              transform: translate(-50%, -50%);
          }
  
          .login-title {
              width: 100%;
              margin: 10px 0px 0px 0px;
              text-align: center;
              line-height: 40px;
              height: 40px;
              font-size: 18px;
              position: relative;
              cursor: move;
          }
  
          .login-input-content {
              margin-top: 20px;
          }
  
          .login-button {
              width: 50%;
              margin: 30px auto 0px auto;
              line-height: 40px;
              font-size: 14px;
              border: #ebebeb 1px solid;
              text-align: center;
          }
  
          .login-bg {
              display: none;
              width: 100%;
              height: 100%;
              position: fixed;
              top: 0px;
              left: 0px;
              background: rgba(0, 0, 0, .3);
          }
  
          a {
              text-decoration: none;
              color: #000000;
          }
  
          .login-button a {
              display: block;
          }
  
          .login-input input.list-input {
              float: left;
              line-height: 35px;
              height: 35px;
              width: 350px;
              border: #ebebeb 1px solid;
              text-indent: 5px;
          }
  
          .login-input {
              overflow: hidden;
              margin: 0px 0px 20px 0px;
          }
  
          .login-input label {
              float: left;
              width: 90px;
              padding-right: 10px;
              text-align: right;
              line-height: 35px;
              height: 35px;
              font-size: 14px;
          }
  
          .login-title span {
              position: absolute;
              font-size: 12px;
              right: -20px;
              top: -30px;
              background: #ffffff;
              border: #ebebeb solid 1px;
              width: 40px;
              height: 40px;
              border-radius: 20px;
          }
      </style>
  </head>
  
  <body>
      <!-- header -->
      <div class="login-header"><a id="link" href="javascript:;">点击，弹出登录框</a></div>
      <!-- login 模块 -->
      <div id="login" class="login">
          <div id="title" class="login-title">登录会员
              <span><a id="closeBtn" href="javascript:void(0);" class="close-login">关闭</a></span>
          </div>
          <div class="login-input-content">
              <div class="login-input">
                  <label>用户名：</label>
                  <input type="text" placeholder="请输入用户名" name="info[username]" id="username" class="list-input">
              </div>
              <div class="login-input">
                  <label>登录密码：</label>
                  <input type="password" placeholder="请输入登录密码" name="info[password]" id="password" class="list-input">
              </div>
          </div>
          <div id="loginBtn" class="login-button"><a href="javascript:void(0);" id="login-button-submit">登录会员</a></div>
      </div>
      <!-- 遮盖层 -->
      <div id="bg" class="login-bg"></div>
  
      <script>
          // 1. 获取元素
          var login = document.querySelector('.login');
          var mask = document.querySelector('.login-bg');
          var link = document.querySelector('#link');
          var closeBtn = document.querySelector('#closeBtn');
          var title = document.querySelector('#title');
          // 2. 点击弹出层这个链接 link  让mask 和login 显示出来
          link.addEventListener('click', function() {
              mask.style.display = 'block';
              login.style.display = 'block';
          })
          // 3. 点击 closeBtn 就隐藏 mask 和 login 
          closeBtn.addEventListener('click', function() {
              mask.style.display = 'none';
              login.style.display = 'none';
          })
          // 4. 开始拖拽
          // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标
          title.addEventListener('mousedown', function(e) {
              // 鼠标到盒子边框的距离：不变
              var x = e.pageX - login.offsetLeft;
              var y = e.pageY - login.offsetTop;
              // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值
              document.addEventListener('mousemove', move)
  			// 起名字，方便删除
              // 必须通过 style 赋值
              function move(e) {
                  login.style.left = e.pageX - x + 'px';
                  login.style.top = e.pageY - y + 'px';
              }
              // (3) 鼠标弹起，就让鼠标移动事件移除
              document.addEventListener('mouseup', function() {
                  document.removeEventListener('mousemove', move);
              })
          })
      </script>
  </body>
  ```
  
- ![image-20220109172211396](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220109172211396.png)



### # 仿京东放大镜

- ① 整个案例可以分为三个功能模块

- ② 鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能

- ③ 黄色的遮挡层跟随鼠标功能。

- ④ 移动黄色遮挡层，大图片跟随移动功能。

- ![image-20220110114502738](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110114502738.png)

- ```css
  .preview_img {
      position: relative;
      height: 398px;
      border: 1px solid #ccc;
  }
  
  .mask {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 300px;
      height: 300px;
      background: #FEDE4F;
      opacity: .5;
      border: 1px solid #ccc;
      cursor: move;
  }
  
  .big {
      display: none;
      position: absolute;
      left: 410px;
      top: 0;
      width: 500px;
      height: 500px;
      background-color: pink;
      z-index: 999;
      border: 1px solid #ccc;
      overflow: hidden;
  }
  
  .big img {
      position: absolute;
      top: 0;
      left: 0;
  }
  ```

- ```js
  window.addEventListener('load', function() {
      var preview_img = document.querySelector('.preview_img');
      var mask = document.querySelector('.mask');
      var big = document.querySelector('.big');
      
      // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子
      // 显示
      preview_img.addEventListener('mouseover', function() {
          mask.style.display = 'block';
          big.style.display = 'block';
      })
      // 隐藏
      preview_img.addEventListener('mouseout', function() {
          mask.style.display = 'none';
          big.style.display = 'none';
      })
      
      // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走
      preview_img.addEventListener('mousemove', function(e) {
          // (1). 先计算出鼠标在盒子内的坐标
          var x = e.pageX - this.offsetLeft;
          var y = e.pageY - this.offsetTop;
          
          // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了
          
          // (3) 需要 mask 移动的距离（向上一半，向左一半）
          var maskX = x - mask.offsetWidth / 2;
          var maskY = y - mask.offsetHeight / 2;
          
          // (4) 如果 x 坐标小于了0, 就让他停在 0 的位置
          // 遮挡层的最大移动距离 (左边距离)
          var maskMax = preview_img.offsetWidth - mask.offsetWidth;
          // x 轴
          if (maskX <= 0) {
              maskX = 0;
          } else if (maskX >= maskMax) {
              maskX = maskMax;
          }
          // y 轴
          if (maskY <= 0) {
              maskY = 0;
          } else if (maskY >= maskMax) {
              maskY = maskMax;
          }
          
          mask.style.left = maskX + 'px';
          mask.style.top = maskY + 'px';
          
          // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
          // 大图
          var bigIMg = document.querySelector('.bigImg');
          
          // 大图片最大移动距离
          var bigMax = bigIMg.offsetWidth - big.offsetWidth;
          
          // 大图片的移动距离 X Y
          var bigX = maskX * bigMax / maskMax;
          var bigY = maskY * bigMax / maskMax;
          
          bigIMg.style.left = -bigX + 'px';
          bigIMg.style.top = -bigY + 'px';
      })
  })
  ```

# 2. 元素可视区 client 系列

- client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的`边框大小`、`元素大小`等，`不含边框 (border)`，`包含 padding`
- ![image-20220110135352051](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110135352051.png)
- ![image-20220110135425088](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110135425088.png)

### # 案例： 淘宝 flexible.js 源码分析

下面三种情况都会刷新页面都会触发 load 事件

1. a标签的超链接
2. F5或者刷新按钮（强制刷新）
3. 前进后退按钮

- ![image-20220110142529803](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110142529803.png)

### * 立即执行函数 

- `(function(param1, param2) {})(param1, param2)` 或者 `(function(){}())`

- 立即执行函数最大的作用就是：**独立创建了一个作用域**, 里面所有的变量都是**局部变量**，不会有**命名冲突**的情况

- ```js
  <body>
      <script>
          // 1.立即执行函数: 不需要调用，立马能够自己执行的函数
          function fn() {
              console.log(1);
          }
          fn();
          // 2. 写法 也可以传递参数进来
          // 1.(function() {})()    或者  2. (function(){}());
          (function(a, b) {
              console.log(a + b);
              var num = 10;
          })(1, 2); // 第二个小括号可以看做是调用函数
          (function sum(a, b) {
              console.log(a + b);
              var num = 10; // 局部变量
          }(2, 3));
          // 3. 立即执行函数最大的作用就是 独立创建了一个作用域, 里面所有的变量都是局部变量 不会有命名冲突的情况
      </script>
  </body>
  ```

# 3. 元素滚动 scroll 系列

## 3.1 元素 scroll 系列属性

- scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该`元素的大小`、`滚动距离`等。
  - 不包含边框 (border)
  - 包含 padding
  - 得到 **内容实际大小**
- ![image-20220110150156659](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110150156659.png)
- ![image-20220110150313678](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110150313678.png)

## 3.2 页面被卷去的头部

- 如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。**滚动条在滚动时**会触发 `onscroll` 事件。

### # 案例：滚动侧边栏

1. 需要用到页面滚动事件 `scroll` 因为是页面滚动，所以事件源是 document
2. 滚动到某个位置，就是判断页面被卷去的上部值。
3. 页面被卷去的头部：可以通过`window.pageYOffset` 获得 如果是被卷去的左侧 `window.pageXOffset`
4. 注意，元素被卷去的头部是 `element.scrollTop` , 如果是页面被卷去的头部 则是 `window.pageYOffset`
5. 其实这个值 可以通过盒子的 `offsetTop` 可以得到，如果大于等于这个值，就可以让盒子固定定位了

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          .slider-bar {
              position: absolute;
              left: 50%;
              top: 300px;
              margin-left: 600px;
              width: 45px;
              height: 130px;
              background-color: pink;
          }
  
          .w {
              width: 1200px;
              margin: 10px auto;
          }
  
          .header {
              height: 150px;
              background-color: purple;
          }
  
          .banner {
              height: 250px;
              background-color: skyblue;
          }
  
          .main {
              height: 1000px;
              background-color: yellowgreen;
          }
  
          span {
              display: none;
              position: absolute;
              bottom: 0;
          }
      </style>
  </head>
  
  <body>
      <div class="slider-bar">
          <span class="goBack">返回顶部</span>
      </div>
      <div class="header w">头部区域</div>
      <div class="banner w">banner区域</div>
      <div class="main w">主体部分</div>
      <script>
          //1. 获取元素
          var sliderbar = document.querySelector('.slider-bar');
          var banner = document.querySelector('.banner');
          // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
          var bannerTop = banner.offsetTop
          // 当我们侧边栏固定定位之后应该变化的数值
          var sliderbarTop = sliderbar.offsetTop - bannerTop;
          // 获取main 主体元素
          var main = document.querySelector('.main');
          var goBack = document.querySelector('.goBack');
          var mainTop = main.offsetTop;
          // 2. 页面滚动事件 scroll
          document.addEventListener('scroll', function() {
              // window.pageYOffset 页面被卷去的头部
              // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
              if (window.pageYOffset >= bannerTop) {
                  sliderbar.style.position = 'fixed';
                  sliderbar.style.top = sliderbarTop + 'px';
              } else {
                  sliderbar.style.position = 'absolute';
                  sliderbar.style.top = '300px';
              }
              // 4. 当我们页面滚动到main盒子，就显示 goback模块
              if (window.pageYOffset >= mainTop) {
                  goBack.style.display = 'block';
              } else {
                  goBack.style.display = 'none';
              }
  
          })
      </script>
  </body>
  ```

## 3.3 页面被卷去的头部兼容性解决方案

需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：

1. 声明了 DTD，使用 `document.documentElement.scrollTop`
2. 未声明 DTD，使用 `document.body.scrollTop`
3. 新方法 `window.pageYOffset` 和 `window.pageXOffset`，IE9 开始支持

- ```js
  function getScroll() {
      return {
          left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
          top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
      };
  }
  ```

# 三大系列总结

- 他们主要用法：
  1. `offset`系列 经常用于获得元素位置 `offsetLeft`, `offsetTop`
  2. `client` 经常用于获取元素大小 `clientWidth`, `clientHeight`
  3. `scroll` 经常用于获取滚动距离 `scrollTop`, `scrollLeft`
  4. 注意页面滚动的距离通过 `window.pageXOffset` 获得
- ![image-20220110160053998](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160053998.png)

- ![image-20220110160058674](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160058674.png)
- ![image-20220110160114838](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160114838.png)
- ![image-20220110160134272](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110160134272.png)



# * mouseenter 和mouseover的区别

## * 1 mouseenter 鼠标事件

- 当鼠标移动到元素上时就会触发 `mouseenter` 事件
- 类似 `mouseover`，它们两者之间的差别是
- `mouseover` 鼠标 **经过自身盒子** 会触发，**经过子盒子** 还会触发。 `mouseenter` 只会 **经过自身盒子** 触发
- 之所以这样，就是因为`mouseenter`不会冒泡。 mouseover 进入内部子盒子后，会冒泡到外部盒子
- 跟`mouseenter`搭配 鼠标离开 `mouseleave` 同样不会冒泡

# 4. 动画函数封装

## 4.1 动画实现原理

- **核心原理**：通过定时器 `setInterval()` 不断移动盒子位置。

### 实现步骤：

- 获得盒子当前位置
- 让盒子在当前位置加上1个移动距离
- 利用定时器不断重复这个操作
- 加一个结束定时器的条件
- 注意此元素需要 **添加定位**，才能使用`element.style.left`

## 4.2 动画函数简单封装

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              position: absolute;
              left: 0;
              width: 100px;
              height: 100px;
              background-color: pink;
          }
          
          span {
              position: absolute;
              left: 0;
              top: 200px;
              display: block;
              width: 150px;
              height: 150px;
              background-color: purple;
          }
      </style>
  </head>
  
  <body>
      <div></div>
      <span>夏雨荷</span>
      <script>
          // 简单动画函数封装obj目标对象 target 目标位置
          function animate(obj, target) {
              var timer = setInterval(function() {
                  if (obj.offsetLeft >= target) {
                      // 停止动画 本质是停止定时器
                      clearInterval(timer);
                  }
                  obj.style.left = obj.offsetLeft + 1 + 'px';
  
              }, 30);
          }
  
          var div = document.querySelector('div');
          var span = document.querySelector('span');
          // 调用函数
          animate(div, 300);
          animate(span, 200);
      </script>
  </body>
  ```

- ![image-20220110165933859](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110165933859.png)



## 4.3 动画函数给不同元素记录不同定时器

- 如果多个元素都使用这个动画函数，每次都要 var 声明定时器。我们可以**给不同的元素使用不同的定时器**（自
  己专门用自己的定时器）。

- **核心原理**：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。

- ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
          div {
              position: absolute;
              left: 0;
              width: 100px;
              height: 100px;
              background-color: pink;
          }
  
          span {
              position: absolute;
              left: 0;
              top: 200px;
              display: block;
              width: 150px;
              height: 150px;
              background-color: purple;
          }
      </style>
  </head>
  
  <body>
      <button>点击夏雨荷才走</button>
      <div></div>
      <span>夏雨荷</span>
      <script>
          // var obj = {};
          // obj.name = 'andy';
          // 简单动画函数封装obj目标对象 target 目标位置
          // 给不同的元素指定了不同的定时器
          function animate(obj, target) {
              // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
              // 解决方案就是 让我们元素只有一个定时器执行
              // 先清除以前的定时器，只保留当前的一个定时器执行
              clearInterval(obj.timer);
              obj.timer = setInterval(function() {
                  if (obj.offsetLeft >= target) {
                      // 停止动画 本质是停止定时器
                      clearInterval(obj.timer);
                  }
                  obj.style.left = obj.offsetLeft + 1 + 'px';
  
              }, 30);
          }
  
          var div = document.querySelector('div');
          var span = document.querySelector('span');
          var btn = document.querySelector('button');
          // 调用函数
          animate(div, 300);
          btn.addEventListener('click', function() {
              animate(span, 200);
          })
      </script>
  </body>
  ```


## 4.4 缓动效果原理

- 缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来

#### 思路：

1. 让盒子**每次移动的距离慢慢变小**，速度就会慢慢落下来。
2. 核心算法： `(目标值 - 现在的位置 ) / 10` 做为每次移动的距离步长
3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器
4. 注意步长值需要取整
5. Math.ceil(step)，让step的结果取整，不产生小数就行了；如果是 floor，则会最后 9 / 10 = 0.9 => 0 不会向前走了

- ```html
  <!DOCTYPE html>
  <html lang="en">
  
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta http-equiv="X-UA-Compatible" content="ie=edge">
          <title>Document</title>
          <style>
              div {
                  position: absolute;
                  left: 0;
                  width: 100px;
                  height: 100px;
                  background-color: pink;
              }
  
              span {
                  position: absolute;
                  left: 0;
                  top: 200px;
                  display: block;
                  width: 150px;
                  height: 150px;
                  background-color: purple;
              }
          </style>
      </head>
  
      <body>
          <button class="btn500">点击夏雨荷到500</button>
          <button class="btn800">点击夏雨荷到800</button>
          <span>夏雨荷</span>
          <script>
              // 缓动动画函数封装obj目标对象 target 目标位置
              // 思路：
              // 1. 让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。
              // 2. 核心算法：(目标值 - 现在的位置) / 10 做为每次移动的距离 步长
              // 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器
              function animate(obj, target) {
                  // 先清除以前的定时器，只保留当前的一个定时器执行
                  clearInterval(obj.timer);
                  obj.timer = setInterval(function() {
                      // 步长值写到定时器的里面
                      // 把我们步长值改为整数 不要出现小数的问题
                      // var step = Math.ceil((target - obj.offsetLeft) / 10);
                      var step = (target - obj.offsetLeft) / 10;
                      // 往前走 or 往后退
                      step = step > 0 ? Math.ceil(step) : Math.floor(step);
                      if (obj.offsetLeft == target) {
                          // 停止动画 本质是停止定时器
                          clearInterval(obj.timer);
                      }
                      // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
                      obj.style.left = obj.offsetLeft + step + 'px';
  
                  }, 15);
              }
              var span = document.querySelector('span');
              var btn500 = document.querySelector('.btn500');
              var btn800 = document.querySelector('.btn800');
  
              btn500.addEventListener('click', function() {
                  // 调用函数
                  animate(span, 500);
              })
              btn800.addEventListener('click', function() {
                  // 调用函数
                  animate(span, 800);
              })
              // 匀速动画 就是 盒子是当前的位置 +  固定的值 10 
              // 缓动动画就是  盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10）
          </script>
      </body>
  
  </html>
  ```

- ![image-20220110215740731](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110215740731.png)

## 4.6 动画函数添加回调函数

- **回调函数原理**：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，
  再执行传进去的这个函数，这个过程就叫做回调。

- 回调函数写的位置：`定时器结束的位置`。

- 如果 `callback` 写在 `setInterval`外面，因为其是**异步**执行的，所以并不是动画完成后才变色（运动过程中，同步变色）。

- ```html
  <body>
      <button class="btn500">点击夏雨荷到500</button>
      <button class="btn800">点击夏雨荷到800</button>
      <span>夏雨荷</span>
      <script>
          // 缓动动画函数封装obj目标对象 target 目标位置
          // 思路：
          // 1. 让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。
          // 2. 核心算法：(目标值 - 现在的位置) / 10 做为每次移动的距离 步长
          // 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器
          function animate(obj, target, callback) {
              // console.log(callback);  callback = function() {}  调用的时候 callback()
  
              // 先清除以前的定时器，只保留当前的一个定时器执行
              clearInterval(obj.timer);
              obj.timer = setInterval(function() {
                  // 步长值写到定时器的里面
                  // 把我们步长值改为整数 不要出现小数的问题
                  // var step = Math.ceil((target - obj.offsetLeft) / 10);
                  var step = (target - obj.offsetLeft) / 10;
                  step = step > 0 ? Math.ceil(step) : Math.floor(step);
                  if (obj.offsetLeft == target) {
                      // 停止动画 本质是停止定时器
                      clearInterval(obj.timer);
                      // 回调函数写到定时器结束里面
                      if (callback) {
                          // 调用函数
                          callback();
                      }
                  }
                  // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
                  obj.style.left = obj.offsetLeft + step + 'px';
  
              }, 15);
          }
          var span = document.querySelector('span');
          var btn500 = document.querySelector('.btn500');
          var btn800 = document.querySelector('.btn800');
  
          btn500.addEventListener('click', function() {
              // 调用函数
              animate(span, 500);
          })
          btn800.addEventListener('click', function() {
              // 调用函数
              animate(span, 800, function() {
                  // alert('你好吗');
                  span.style.backgroundColor = 'red';
              });
          })
          // 匀速动画 就是 盒子是当前的位置 +  固定的值 10 
          // 缓动动画就是  盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10）
      </script>
  </body>
  ```

## 4.7 动画函数封装到单独JS文件里面

因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。
1. 单独新建一个JS文件。
2. HTML文件引入 JS 文件。

- ```html
  
  <body>
      <div class="sliderbar">
          <span>←</span>
          <div class="con">问题反馈</div>
      </div>
  
      <script>
          // 1. 获取元素
          var sliderbar = document.querySelector('.sliderbar');
          var con = document.querySelector('.con');
          // 当我们鼠标经过 sliderbar 就会让 con这个盒子滑动到左侧
          // 当我们鼠标离开 sliderbar 就会让 con这个盒子滑动到右侧
          sliderbar.addEventListener('mouseenter', function() {
              // animate(obj, target, callback);
              animate(con, -160, function() {
                  // 当我们动画执行完毕，就把 ← 改为 →
                  sliderbar.children[0].innerHTML = '→';
              });
  
          })
          sliderbar.addEventListener('mouseleave', function() {
              // animate(obj, target, callback);
              animate(con, 0, function() {
                  sliderbar.children[0].innerHTML = '←';
              });
  
          })
      </script>
  </body>
  ```

- ![image-20220110224014897](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220110224014897.png)

# 5. 常见网页特效案例

## # 案例：网页轮播图

功能需求：
1. 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。
2. 点击右侧按钮一次，图片往左播放一张，以此类推， 左侧按钮同理。
3. 图片播放的同时，下面小圆圈模块跟随一起变化。
4. 点击小圆圈，可以播放相应图片。
5. 鼠标不经过轮播图， 轮播图也会自动播放图片。
6. 鼠标经过，轮播图模块， 自动播放停止。

案例分析

- ![image-20220111170318759](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111170318759.png)

- ![image-20220111170327544](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111170327544.png)

- ![image-20220111170349646](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111170349646.png)

- ![image-20220111170404513](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111170404513.png)

- ![image-20220111171543776](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111171543776.png)

- ![image-20220111180434022](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111180434022.png)

- ![image-20220111171158265](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111171158265.png)

- ```js
  window.addEventListener('load', function() {
      // 1. 获取元素
      var arrow_l = document.querySelector('.arrow-l');
      var arrow_r = document.querySelector('.arrow-r');
      var focus = document.querySelector('.focus');
      var focusWidth = focus.offsetWidth;
      // 2. 鼠标经过focus 就显示隐藏左右按钮
      focus.addEventListener('mouseenter', function() {
          arrow_l.style.display = 'block';
          arrow_r.style.display = 'block';
          clearInterval(timer);
          timer = null; // 清除定时器变量
      });
      focus.addEventListener('mouseleave', function() {
          arrow_l.style.display = 'none';
          arrow_r.style.display = 'none';
          timer = setInterval(function() {
              //手动调用点击事件
              arrow_r.click();
          }, 2000);
      });
      // 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈
      var ul = focus.querySelector('ul');
      var ol = focus.querySelector('.circle');
      // console.log(ul.children.length);
      for (var i = 0; i < ul.children.length; i++) {
          // 创建一个小li 
          var li = document.createElement('li');
          // 记录当前小圆圈的索引号 通过自定义属性来做 
          li.setAttribute('index', i);
          // 把小li插入到ol 里面
          ol.appendChild(li);
          // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件
          li.addEventListener('click', function() {
              // 干掉所有人 把所有的小li 清除 current 类名
              for (var i = 0; i < ol.children.length; i++) {
                  ol.children[i].className = '';
              }
              // 留下我自己  当前的小li 设置current 类名
              this.className = 'current';
              // 5. 点击小圆圈，移动图片 当然移动的是 ul 
              // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值
              // 当我们点击了某个小li 就拿到当前小li 的索引号
              var index = this.getAttribute('index');
              // 当我们点击了某个小li 就要把这个li 的索引号给 num  
              num = index;
              // 当我们点击了某个小li 就要把这个li 的索引号给 circle  
              circle = index;
              // num = circle = index;
              console.log(focusWidth);
              console.log(index);
  
              animate(ul, -index * focusWidth);
          })
      }
      // 把ol里面的第一个小li设置类名为 current
      ol.children[0].className = 'current';
      // 6. 克隆第一张图片(li)放到ul 最后面
      var first = ul.children[0].cloneNode(true);
      ul.appendChild(first);
      // 7. 点击右侧按钮， 图片滚动一张
      var num = 0;
      // circle 控制小圆圈的播放
      var circle = 0;
      // flag 节流阀
      var flag = true;
      arrow_r.addEventListener('click', function() {
          if (flag) {
              flag = false; // 关闭节流阀
              // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0
              if (num == ul.children.length - 1) {
                  ul.style.left = 0;
                  num = 0;
              }
              num++;
              animate(ul, -num * focusWidth, function() {
                  flag = true; // 打开节流阀
              });
              // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
              circle++;
              // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原
              if (circle == ol.children.length) {
                  circle = 0;
              }
              // 调用函数
              circleChange();
          }
      });
  
      // 9. 左侧按钮做法
      arrow_l.addEventListener('click', function() {
          if (flag) {
              flag = false;
              if (num == 0) {
                  num = ul.children.length - 1;
                  ul.style.left = -num * focusWidth + 'px';
  
              }
              num--;
              animate(ul, -num * focusWidth, function() {
                  flag = true;
              });
              // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
              circle--;
              // 如果circle < 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）
              // if (circle < 0) {
              //     circle = ol.children.length - 1;
              // }
              circle = circle < 0 ? ol.children.length - 1 : circle;
              // 调用函数
              circleChange();
          }
      });
  
      function circleChange() {
          // 先清除其余小圆圈的current类名
          for (var i = 0; i < ol.children.length; i++) {
              ol.children[i].className = '';
          }
          // 留下当前的小圆圈的current类名
          ol.children[circle].className = 'current';
      }
      // 10. 自动播放轮播图
      var timer = setInterval(function() {
          //手动调用点击事件
          arrow_r.click();
      }, 2000);
  
  })
  ```

- ![image-20220111171450134](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111171450134.png)

### 5.1 节流阀

- 防止轮播图按钮连续点击造成播放过快。
- 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。
- 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。
- 开始设置一个变量 `var flag = true;`
- `If(flag) {flag = false; do something（播放图片 ）}` 关闭水龙头
- 利用回调函数 动画执行完毕， `flag = true` 打开水龙头
- 代码参考上方

## # 案例：返回顶部

- 滚动窗口至文档中的特定位置。
- `window.scroll(x, y)`
- 注意，里面的x和y 不跟单位，直接写数字

### 案例分析

1. 带有动画的返回顶部
2.  此时可以继续使用我们封装的动画函数
3. 只需要把所有的 left 相关的值 改为 跟 页面垂直滚动距离相关就可以了
4. 页面滚动了多少，可以通过 `window.pageYOffset` 得到
5. 最后是页面滚动，使用 `window.scroll(x,y)`

```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .slider-bar {
            position: absolute;
            left: 50%;
            top: 300px;
            margin-left: 600px;
            width: 45px;
            height: 130px;
            background-color: pink;
        }

        .w {
            width: 1200px;
            margin: 10px auto;
        }

        .header {
            height: 150px;
            background-color: purple;
        }

        .banner {
            height: 250px;
            background-color: skyblue;
        }

        .main {
            height: 1000px;
            background-color: yellowgreen;
        }

        span {
            display: none;
            position: absolute;
            bottom: 0;
        }
    </style>
</head>

<body>
    <div class="slider-bar">
        <span class="goBack">返回顶部</span>
    </div>
    <div class="header w">头部区域</div>
    <div class="banner w">banner区域</div>
    <div class="main w">主体部分</div>
    <script>
        //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
        // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
            // console.log(11);
            // window.pageYOffset 页面被卷去的头部
            // console.log(window.pageYOffset);
            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
            if (window.pageYOffset >= bannerTop) {
                sliderbar.style.position = 'fixed';
                sliderbar.style.top = sliderbarTop + 'px';
            } else {
                sliderbar.style.position = 'absolute';
                sliderbar.style.top = '300px';
            }
            // 4. 当我们页面滚动到main盒子，就显示 goback模块
            if (window.pageYOffset >= mainTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';
            }

        })
        // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方
        goBack.addEventListener('click', function() {
            // 里面的x和y 不跟单位的 直接写数字即可
            // window.scroll(0, 0);
            // 因为是窗口滚动 所以对象是window
            animate(window, 0);
        });
        // 动画函数
        function animate(obj, target, callback) {
            // console.log(callback);  callback = function() {}  调用的时候 callback()

            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function() {
                // 步长值写到定时器的里面
                // 把我们步长值改为整数 不要出现小数的问题
                // var step = Math.ceil((target - obj.offsetLeft) / 10);
                var step = (target - window.pageYOffset) / 10;
                step = step > 0 ? Math.ceil(step) : Math.floor(step);
                if (window.pageYOffset == target) {
                    // 停止动画 本质是停止定时器
                    clearInterval(obj.timer);
                    // 回调函数写到定时器结束里面
                    // if (callback) {
                    //     // 调用函数
                    //     callback();
                    // }
                    callback && callback();
                }
                // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
                // obj.style.left = window.pageYOffset + step + 'px';
                window.scroll(0, window.pageYOffset + step);
            }, 15);
        }
    </script>
</body>
```

## # 案例：筋头云案例

- 鼠标经过某个小li， 筋斗云跟这到当前小li位置
- 鼠标离开这个小li， 筋斗云复原为原来的位置
- 鼠标点击了某个小li， 筋斗云就会留在点击这个小li 的位置

### 案例分析

1. 利用动画函数做动画效果
2. 原先筋斗云的起始位置是0
3. 鼠标经过某个小li， 把当前小li 的 offsetLeft 位置 做为目标值即可
4. 鼠标离开某个小li， 就把目标值设为 0
5. 如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置

- ```html
  <!DOCTYPE html>
  <html>
  
      <head lang="en">
          <meta charset="UTF-8">
          <title></title>
          <style>
              * {
                  margin: 0;
                  padding: 0
              }
  
              ul {
                  list-style: none;
              }
  
              body {
                  background-color: black;
              }
  
              .c-nav {
                  width: 900px;
                  height: 42px;
                  background: #fff url(images/rss.png) no-repeat right center;
                  margin: 100px auto;
                  border-radius: 5px;
                  position: relative;
              }
  
              .c-nav ul {
                  position: absolute;
              }
  
              .c-nav li {
                  float: left;
                  width: 83px;
                  text-align: center;
                  line-height: 42px;
              }
  
              .c-nav li a {
                  color: #333;
                  text-decoration: none;
                  display: inline-block;
                  height: 42px;
              }
  
              .c-nav li a:hover {
                  color: white;
              }
  
              .c-nav li.current a {
                  color: #0dff1d;
              }
  
              .cloud {
                  position: absolute;
                  left: 0;
                  top: 0;
                  width: 83px;
                  height: 42px;
                  background: url(images/cloud.gif) no-repeat;
              }
          </style>
          <script src="animate.js"></script>
          <script>
              window.addEventListener('load', function() {
                  // 1. 获取元素
                  var cloud = document.querySelector('.cloud');
                  var c_nav = document.querySelector('.c-nav');
                  var lis = c_nav.querySelectorAll('li');
                  // 2. 给所有的小li绑定事件 
                  // 这个current 做为筋斗云的起始位置
                  var current = 0;
                  for (var i = 0; i < lis.length; i++) {
                      // (1) 鼠标经过把当前小li 的位置做为目标值
                      lis[i].addEventListener('mouseenter', function() {
                          animate(cloud, this.offsetLeft);
                      });
                      // (2) 鼠标离开就回到起始的位置 
                      lis[i].addEventListener('mouseleave', function() {
                          animate(cloud, current);
                      });
                      // (3) 当我们鼠标点击，就把当前位置做为目标值
                      lis[i].addEventListener('click', function() {
                          current = this.offsetLeft;
                      });
                  }
              })
          </script>
      </head>
  
      <body>
          <div id="c_nav" class="c-nav">
              <span class="cloud"></span>
              <ul>
                  <li class="current"><a href="#">首页新闻</a></li>
                  <li><a href="#">师资力量</a></li>
                  <li><a href="#">活动策划</a></li>
                  <li><a href="#">企业文化</a></li>
                  <li><a href="#">招聘信息</a></li>
                  <li><a href="#">公司简介</a></li>
                  <li><a href="#">我是佩奇</a></li>
                  <li><a href="#">啥是佩奇</a></li>
              </ul>
          </div>
      </body>
  
  </html>
  ```

- ![image-20220111194325069](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20220111194325069.png)


