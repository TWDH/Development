# 2.第二章-排序

## 1. 选择排序

- 首先，找到数组中最小的那个元素
- 其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）
- 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。
- 这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者
- ![image-20211116145344953](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211116145344953.png)

## 2. 插入排序

- 通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。
- 在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。
- 这种算法叫做插入排序
- 与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了
- 和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。
- ![image-20211116150650046](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211116150650046.png)

## 3. 归并排序

- ### 原地归并的抽象方法

  - 该方法先将所有元素复制到aux[]中，然后再归并回a[]中。方法在归并时（第二个for循环）进行了4个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。
  - ![image-20211119103007419](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119103007419.png)

- ### 自顶向下的归并排序 (分治法) 

  - ![image-20211119103304607](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119103304607.png)
  - ![image-20211119103720470](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119103720470.png)
  - ![image-20211119104534705](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119104534705.png)
  - 使用**插入排序**处理小规模的子数组（比如**长度小于15**）一般可以将归并排序的运行**时间缩短10%～15%**
  - 如果**a[mid]小于等于a[mid+1]**，我们就认为数组**已经是有序**的并跳过merge()方法

- ##  自底向上的归并排序

  - 首先我们进行的是两两归并（把每个元素想象成一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并成一个有4个元素的数组），然后是八八的归并，一直下去。
  - ![image-20211119111609325](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119111609325.png)
  - ![image-20211119111622540](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119111622540.png)
  - 当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同
  - 没有任何基于比较的算法能够保证使用少于lg（N!）～NlgN次比较将长度为N的数组排序
    - 任意算法的比较次数至少：**lgN!～NlgN**
  - 归并排序是一种渐进最优的基于比较排序的算法
    - 归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是～**NlgN**

- ### Concern

  - 归并排序的空间复杂度不是最优的
  - 在实践中不一定会遇到最坏情况
  - 除了比较，算法的其他操作（例如访问数组）也可能很重要
  - 不进行比较也能将某些数据排序

## 4. 快速排序

- 原地排序（只需要一个很小的辅助栈）

- 长度为 N 的数组排序所需的时间和 `NlgN` 成正比

- 快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序

- **归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序**

  - 递归调用发生在处理整个数组之**前**

- **快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了**

  - 递归调用发生在处理整个数组之后

- ![image-20211119121245699](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119121245699.png)

- ![image-20211119122202845](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211119122202845.png)

- ### 满足下面三个条件：

  - 对于某个 `pivot`, `a[pivot]`已经排定；
  - `a[lo]` 到 `a[j-1]` 中的所有元素都不大于`a[pivot]`；
    - 从数组的左端开始向右扫描直到找到一个大于等于它的元素
  - `a[pivot+1]`到`a[hi]`中的所有元素都不小于`a[pivot]`
    - 从数组的右端开始向左扫描直到找到一个小于等于它的元素

- 因为切分过程总是能排定一个元素，用归纳法不难证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组（有序且没有任何元素大于切分元素）、切分元素和右子数组（有序且没有任何元素小于切分元素）组成的结果数组也一定是有序的。

- ### 处理切分元素值有重复的情况

  - 遇到 **大于等于** 切分元素值的元素时停下
  - 遇到 **小于等于** 切分元素值的元素时停下





































































