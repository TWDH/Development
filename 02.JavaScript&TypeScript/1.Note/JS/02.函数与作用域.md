# 02.函数与作用域

# 1 函数

## 1.1 函数的使用

- 函数在使用时分为两步：**声明函数**和**调用函数**

### ①声明函数

- ```js
  //声明函数
  function 函数名(){
       //函数体代码
  }
  ```

- `function` 是声明函数的关键字,**必须小写**

- 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 `getSum`

### ②调用函数

- ```js
  //调用函数
  函数名(); //通过调用函数名来执行函数体代码
  ```

- 调用的时候**千万不要忘记添加小括号**

- 口诀：函数不调用，自己不执行

- **注意**：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码

## 1.2、函数的封装

- 函数的封装是把一个或者多个功能通过 **函数的方式** 封装起来，对外只提供一个简单的函数接口

## 1.3、函数的参数

- **在声明函数时**，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在**调用该函数**时，同样也需要传递相应的参数，这些参数被称为**实参**。

- ![image-20211128161240893](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211128161240893.png)

- **参数的作用** : 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递不同的值**进去

  - ```js
    // 带参数的函数声明
    function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
      // 函数体
    }
    
    
    // 带参数的函数调用
    函数名(实参1, 实参2, 实参3...); 
    ```

- 函数调用的时候实参值是传递给形参的

- 形参简单理解为:**不用声明的变量**

- 实参和形参的多个参数之间用 `逗号(,)` 分隔

### 1.3.2、形参和实参个数不匹配

- ![image-20211128161751131](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20211128161751131.png)

- ```js
  function sum(num1, num2) {
      console.log(num1 + num2);
  }
  sum(100, 200);             // 300，形参和实参个数相等，输出正确结果
  
  sum(100, 400, 500, 700);   // 500，实参个数多于形参，只取到形参的个数
  
  sum(200);                  // 实参个数少于形参，多的形参定义为undefined，结果为NaN
  ```

- **注意：在JavaScript中，形参的默认值是undefined**

## 1.4、函数的返回值

### 1.4.1、return语句

- 有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

  - ```js
    // 声明函数
    function 函数名（）{
        ...
        return  需要返回的值;
    }
    // 调用函数
    函数名();    // 此时调用函数就可以得到函数体内return 后面的值
    ```

- 在使用 return 语句时，函数会停止执行，并返回指定的值

- 如果函数没有 return ，返回的值是 undefined

## 1.5 arguments的使用

- 当我们不确定有多少个参数传递的时候，可以用 `arguments` 来获取。在 JavaScript 中，`arguments` 实际上它是**当前函数的一个内置对象**

- 所有函数都内置了一个 `arguments` 对象，`arguments` 对象中存储了传递的所有实参

  - **arguments**存放的是传递过来的实参
  - **arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点**
    - ①：具有 length 属性
    - ②：按索引方式储存数据
    - ③：不具有数组的 push , pop 等方法

- ```js
  // 函数声明
  function fn() {
      console.log(arguments);  //里面存储了所有传递过来的实参
      console.log(arrguments.length); // 3
      console.log(arrguments[2]); // 3
  }
  
  // 函数调用
  fn(1,2,3);
  ```

- ```js
  // 例如：利用函数求任意个数的最大值 
  function maxValue() {
      var max = arguments[0];
      for (var i = 0; i < arguments.length; i++) {
          if (max < arguments[i]) {
              max = arguments[i];
          }
      }
      return max;
  }
  console.log(maxValue(2, 4, 5, 9)); // 9
  console.log(maxValue(12, 4, 9)); // 12
  ```

### 🔥 函数调用另外一个函数

- 因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。具体演示在下面的函数练习中会有

## 1.7 函数的两种声明方式

### 1.7.1、自定义函数方式(命名函数)

- 利用函数关键字 `function` 自定义函数方式

- ```js
  // 声明定义方式
  function fn() {...}
  
  // 调用  
  fn();
  ```

- **因为有名字，所以也被称为命名函数**

- **调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面**

### 1.7.2 函数表达式方式(匿名函数)

- ```js
  // 这是函数表达式写法，匿名函数后面跟分号结束
  var fn = function(){...};
  
  // 调用的方式，函数调用必须写到函数体下面
  fn();
  ```

- 因为函数没有名字，所以也称为**匿名函数**

- 这个fn 里面存储的是一个函数

- **函数调用的代码必须写到函数体后面**

# 2 作用域

JavaScript (ES6前) 中的作用域有两种：

- 全局作用域
- 局部作用域(函数作用域)

### 2.1 全局作用域🔥

- 作用于**所有代码**执行的环境(整个 script 标签内部)或者一个独立的 js 文件

### 2.2 局部（函数）作用域🔥

- **作用于函数内**的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域

### 2.3 JS 没有块级作用域🔥

- 块作用域由 {} 包括

- 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用

  - ```js
    if(true){
        int num = 123;
        System.out.println(num);	// 123
    }
    System.out.println(num);		// 报错
    ```

- JS 中没有块级作用域(在ES6之前)

  - ```js
    if(true){
        int num = 123;
        System.out.println(num);	// 123
    }
    System.out.println(num);		// 123
    ```

# 3 变量的作用域

在JavaScript中，根据作用域的不同，变量可以分为两种：

- 全局变量
- 局部变量

## 3.1 全局变量

在全局作用域下声明的变量叫做全局变量（**在函数外部定义的变量**）

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下 `var` 声明的变量 是**全局变量**
- 特殊情况下，在函数内不使用 `var` 声明的变量也是全局变量（不建议使用）

## 3.2 局部变量

在局部作用域下声明的变量叫做局部变量（**在函数内部定义的变量**）

- 局部变量只能在该函数内部使用
- 在函数内部 var 声明的变量是局部变量
- 函数的**形参**实际上就是**局部变量**

## 3.3 区别

- 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间

# 4 作用域链

1. 只要是代码，就至少有一个作用域

2. 写在**函数内部**的叫**局部作用域**

3. 如果**函数中还有函数**，那么在这个作用域中就又可以**诞生一个作用域**

4. 根据在**内部函数可以访问外部函数变量**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

5. ```js
   // 作用域链: 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链表
   
   var num = 10;
   funtion fn() { //外部函数
       var num = 20;
       
       function fun() { //内部函数
           console.log(num);  // 20 ,一级一级访问
       }
   }
   ```

6. 作用域链：采取 **就近原则** 的方式来查变量最终的值。

# 5 预解析

例子

- fdsaf 
  
- 







































